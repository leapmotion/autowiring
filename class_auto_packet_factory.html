<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: AutoPacketFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">1.0.3</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_auto_packet_factory.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_auto_packet_factory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AutoPacketFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A configurable factory class for pipeline packets with a built-in object pool  
 <a href="class_auto_packet_factory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_auto_packet_factory_8h_source.html">AutoPacketFactory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AutoPacketFactory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_auto_packet_factory.png" usemap="#AutoPacketFactory_map" alt=""/>
  <map id="AutoPacketFactory_map" name="AutoPacketFactory_map">
<area href="class_context_member.html" title="A class that must be inherited in order to be a member of a context heriarchy " alt="ContextMember" shape="rect" coords="0,0,120,24"/>
<area href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ..." alt="CoreRunnable" shape="rect" coords="130,0,250,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ab0b5522e86a18ae648c1fdc2995ddd"><td class="memItemLeft" align="right" valign="top">const autowiring::AutoFilterDescriptor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a4ab0b5522e86a18ae648c1fdc2995ddd">AddSubscriber</a> (const autowiring::AutoFilterDescriptor &amp;rhs)</td></tr>
<tr class="memdesc:a4ab0b5522e86a18ae648c1fdc2995ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the passed subscriber, if it defines a method called AutoFilter  <a href="#a4ab0b5522e86a18ae648c1fdc2995ddd">More...</a><br /></td></tr>
<tr class="separator:a4ab0b5522e86a18ae648c1fdc2995ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05639d9fca94f18e9f6f01ba5ad00b76"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a05639d9fca94f18e9f6f01ba5ad00b76"><td class="memTemplItemLeft" align="right" valign="top">autowiring::AutoFilterDescriptor&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a05639d9fca94f18e9f6f01ba5ad00b76">AddSubscriber</a> (const std::shared_ptr&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a05639d9fca94f18e9f6f01ba5ad00b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience override of AddSubscriber  <a href="#a05639d9fca94f18e9f6f01ba5ad00b76">More...</a><br /></td></tr>
<tr class="separator:a05639d9fca94f18e9f6f01ba5ad00b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c26425753556533cdec00968acdcffa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5c26425753556533cdec00968acdcffa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a5c26425753556533cdec00968acdcffa">AppendAutoFiltersTo</a> (T &amp;container) const </td></tr>
<tr class="memdesc:a5c26425753556533cdec00968acdcffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the internal set of AutoFilter members to the specified container  <a href="#a5c26425753556533cdec00968acdcffa">More...</a><br /></td></tr>
<tr class="separator:a5c26425753556533cdec00968acdcffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6df86d37b611fd7da03b5d89088d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a7f6df86d37b611fd7da03b5d89088d4e">Clear</a> (void)</td></tr>
<tr class="memdesc:a7f6df86d37b611fd7da03b5d89088d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes this <a class="el" href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool ">AutoPacketFactory</a> to release all of its packet subscribers  <a href="#a7f6df86d37b611fd7da03b5d89088d4e">More...</a><br /></td></tr>
<tr class="separator:a7f6df86d37b611fd7da03b5d89088d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c82c3395752edb771d858183c22dbce"><td class="memItemLeft" align="right" valign="top">autowiring::SatCounter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a5c82c3395752edb771d858183c22dbce">CreateSatCounterList</a> (void) const </td></tr>
<tr class="memdesc:a5c82c3395752edb771d858183c22dbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linked list of saturation counters  <a href="#a5c82c3395752edb771d858183c22dbce">More...</a><br /></td></tr>
<tr class="separator:a5c82c3395752edb771d858183c22dbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec111268055a58305cb0f8b582b73e0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a7ec111268055a58305cb0f8b582b73e0">CurrentPacket</a> (void)</td></tr>
<tr class="separator:a7ec111268055a58305cb0f8b582b73e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcff2e0a4fd863f3a618973c6c5d6b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#adcff2e0a4fd863f3a618973c6c5d6b3f">DoAdditionalWait</a> (void) override</td></tr>
<tr class="memdesc:adcff2e0a4fd863f3a618973c6c5d6b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untimed variant of DoAdditionalWait  <a href="#adcff2e0a4fd863f3a618973c6c5d6b3f">More...</a><br /></td></tr>
<tr class="separator:adcff2e0a4fd863f3a618973c6c5d6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa969b149c74e23e0ee708481ec90ec94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#aa969b149c74e23e0ee708481ec90ec94">DoAdditionalWait</a> (std::chrono::nanoseconds timeout) override</td></tr>
<tr class="memdesc:aa969b149c74e23e0ee708481ec90ec94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked just before control is returned to the user.  <a href="#aa969b149c74e23e0ee708481ec90ec94">More...</a><br /></td></tr>
<tr class="separator:aa969b149c74e23e0ee708481ec90ec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a8ae4780b5a7eb3bbcbaa5ba85c9d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; autowiring::AutoFilterDescriptor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#af8a8ae4780b5a7eb3bbcbaa5ba85c9d9">GetAutoFilters</a> (void) const </td></tr>
<tr class="separator:af8a8ae4780b5a7eb3bbcbaa5ba85c9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14ee291b0bdb1c8131f268c4a7265c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#aa14ee291b0bdb1c8131f268c4a7265c0">GetMeanPacketLifetime</a> (void)</td></tr>
<tr class="memdesc:aa14ee291b0bdb1c8131f268c4a7265c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean lifespan of AutoPackets in nanoseconds since the last statistics reset.  <a href="#aa14ee291b0bdb1c8131f268c4a7265c0">More...</a><br /></td></tr>
<tr class="separator:aa14ee291b0bdb1c8131f268c4a7265c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc9c322e9fe5257202c0d00b68a5059"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdc9c322e9fe5257202c0d00b68a5059"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#acdc9c322e9fe5257202c0d00b68a5059">GetOutstandingPacketCount</a> (void) const </td></tr>
<tr class="memdesc:acdc9c322e9fe5257202c0d00b68a5059"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>the number of outstanding AutoPackets</dd></dl>
<br /></td></tr>
<tr class="separator:acdc9c322e9fe5257202c0d00b68a5059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8743ffc532d0fe739782a2f843a86467"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a8743ffc532d0fe739782a2f843a86467">GetPacketLifetimeStandardDeviation</a> (void)</td></tr>
<tr class="memdesc:a8743ffc532d0fe739782a2f843a86467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of the lifespans of AutoPackets in nanoseconds since most recent statistics reset.  <a href="#a8743ffc532d0fe739782a2f843a86467">More...</a><br /></td></tr>
<tr class="separator:a8743ffc532d0fe739782a2f843a86467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002ce21f9b397665baa809d20fcdb6eb"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#a002ce21f9b397665baa809d20fcdb6eb">GetTotalPacketCount</a> (void)</td></tr>
<tr class="memdesc:a002ce21f9b397665baa809d20fcdb6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of packets which have recorded duration statistics since the most recent statistics reset.  <a href="#a002ce21f9b397665baa809d20fcdb6eb">More...</a><br /></td></tr>
<tr class="separator:a002ce21f9b397665baa809d20fcdb6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab034744b4a0172e4e3e9426fc980a7c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab034744b4a0172e4e3e9426fc980a7c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#ab034744b4a0172e4e3e9426fc980a7c1">IsRunning</a> (void) const  override</td></tr>
<tr class="memdesc:ab034744b4a0172e4e3e9426fc980a7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable is currently running. <br /></td></tr>
<tr class="separator:ab034744b4a0172e4e3e9426fc980a7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddbad76bc70d641a05fcccc4643be20"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#adddbad76bc70d641a05fcccc4643be20">NewPacket</a> (void)</td></tr>
<tr class="memdesc:adddbad76bc70d641a05fcccc4643be20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a new packet from the object pool and configures it with the current satisfaction graph  <a href="#adddbad76bc70d641a05fcccc4643be20">More...</a><br /></td></tr>
<tr class="separator:adddbad76bc70d641a05fcccc4643be20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60dd197a5520d5b06b1a1c9bfa8dda9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#aa60dd197a5520d5b06b1a1c9bfa8dda9">OnStart</a> (void) override</td></tr>
<tr class="memdesc:aa60dd197a5520d5b06b1a1c9bfa8dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the <a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12" title="Causes this runnable to begin processing. ">Start()</a> method. Override this method to perform any needed setup  <a href="#aa60dd197a5520d5b06b1a1c9bfa8dda9">More...</a><br /></td></tr>
<tr class="separator:aa60dd197a5520d5b06b1a1c9bfa8dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8615d15ffbe346e4f2f6976e8f4dcdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#ac8615d15ffbe346e4f2f6976e8f4dcdc">OnStop</a> (bool graceful) override</td></tr>
<tr class="memdesc:ac8615d15ffbe346e4f2f6976e8f4dcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Override this method to perform any needed cleanup.  <a href="#ac8615d15ffbe346e4f2f6976e8f4dcdc">More...</a><br /></td></tr>
<tr class="separator:ac8615d15ffbe346e4f2f6976e8f4dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa544dce7f6f2174cf839a403c094ca"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:aeaa544dce7f6f2174cf839a403c094ca"><td class="memTemplItemLeft" align="right" valign="top">autowiring::AutoFilterDescriptor&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#aeaa544dce7f6f2174cf839a403c094ca">operator+=</a> (Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:aeaa544dce7f6f2174cf839a403c094ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convienance overload of operator+= to add a subscriber from a lambda  <a href="#aeaa544dce7f6f2174cf839a403c094ca">More...</a><br /></td></tr>
<tr class="separator:aeaa544dce7f6f2174cf839a403c094ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58f46cdcfa605b2dbed77b96824fdf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#ad58f46cdcfa605b2dbed77b96824fdf5">operator-=</a> (const autowiring::AutoFilterDescriptor &amp;desc)</td></tr>
<tr class="memdesc:ad58f46cdcfa605b2dbed77b96824fdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded counterpart to RemoveSubscriber  <a href="#ad58f46cdcfa605b2dbed77b96824fdf5">More...</a><br /></td></tr>
<tr class="separator:ad58f46cdcfa605b2dbed77b96824fdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98c3ea149c6c3edf0d2d647012d884f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#ad98c3ea149c6c3edf0d2d647012d884f">RecordPacketDuration</a> (std::chrono::nanoseconds duration)</td></tr>
<tr class="memdesc:ad98c3ea149c6c3edf0d2d647012d884f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by each <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>'s Finalize method to allow the factory to record statistics about packet lifespan.  <a href="#ad98c3ea149c6c3edf0d2d647012d884f">More...</a><br /></td></tr>
<tr class="separator:ad98c3ea149c6c3edf0d2d647012d884f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c9683a9cea604f88986114920ae2c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#aa8c9683a9cea604f88986114920ae2c6">RemoveSubscriber</a> (const autowiring::AutoFilterDescriptor &amp;autoFilter)</td></tr>
<tr class="memdesc:aa8c9683a9cea604f88986114920ae2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the designated AutoFilter from this factory  <a href="#aa8c9683a9cea604f88986114920ae2c6">More...</a><br /></td></tr>
<tr class="separator:aa8c9683a9cea604f88986114920ae2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae582e1a1e37dae158b22ec0ad322b7d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#ae582e1a1e37dae158b22ec0ad322b7d7">ResetPacketStatistics</a> (void)</td></tr>
<tr class="memdesc:ae582e1a1e37dae158b22ec0ad322b7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the statistics accumulators stored by the <a class="el" href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool ">AutoPacketFactory</a>.  <a href="#ae582e1a1e37dae158b22ec0ad322b7d7">More...</a><br /></td></tr>
<tr class="separator:ae582e1a1e37dae158b22ec0ad322b7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_context_member"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_context_member')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_context_member.html">ContextMember</a></td></tr>
<tr class="memitem:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_context_member.html#a256451cd0e6dfb1b9c6312cd2b0a4129">GetContext</a> (void) const </td></tr>
<tr class="memdesc:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the context associated with this object.  <a href="#a256451cd0e6dfb1b9c6312cd2b0a4129">More...</a><br /></td></tr>
<tr class="separator:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_context_member.html#a84efe78dbb81bfa94bb46eaf466a6f77">GetSelf</a> (void) const </td></tr>
<tr class="memdesc:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer that refers to ourselves  <a href="#a84efe78dbb81bfa94bb46eaf466a6f77">More...</a><br /></td></tr>
<tr class="separator:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_context_member.html#ac57af82464416e1763e1d04c50b4c89c">GetSelf</a> (void)</td></tr>
<tr class="memdesc:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer that refers to ourselves  <a href="#ac57af82464416e1763e1d04c50b4c89c">More...</a><br /></td></tr>
<tr class="separator:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_context_member.html#a34e73ac0659e22117582b903b81d2b18">NotifyContextTeardown</a> (void)</td></tr>
<tr class="memdesc:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the parent context when the parent context is about to be destroyed  <a href="#a34e73ac0659e22117582b903b81d2b18">More...</a><br /></td></tr>
<tr class="separator:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_core_runnable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_core_runnable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_core_runnable.html">CoreRunnable</a></td></tr>
<tr class="memitem:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144421b84f8b8fee45838fbe2be6e5c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6">ShouldStop</a> (void) volatile const </td></tr>
<tr class="memdesc:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable should stop. <br /></td></tr>
<tr class="separator:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12">Start</a> (std::shared_ptr&lt; CoreObject &gt; outstanding)</td></tr>
<tr class="memdesc:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes this runnable to begin processing.  <a href="#a4f5e7e482f70200b82d8f0d489eedd12">More...</a><br /></td></tr>
<tr class="separator:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb">Stop</a> (bool graceful=true)</td></tr>
<tr class="memdesc:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops this runnable.  <a href="#a41c3338adf9bf7222b13bbafb564dabb">More...</a><br /></td></tr>
<tr class="separator:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a0aaa1a6490b1b7d16fa63b64a012a9f0">ThreadSleep</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps this thread for the specified duration.  <a href="#a0aaa1a6490b1b7d16fa63b64a012a9f0">More...</a><br /></td></tr>
<tr class="separator:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#acb3c019cfe57942e293c9cec805828e7">Wait</a> (void)</td></tr>
<tr class="memdesc:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely. Returns when this runnable stops.  <a href="#acb3c019cfe57942e293c9cec805828e7">More...</a><br /></td></tr>
<tr class="separator:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4856481bde70b25d28bac86876cadf88">WaitFor</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the specified amount of time.  <a href="#a4856481bde70b25d28bac86876cadf88">More...</a><br /></td></tr>
<tr class="separator:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#aa8b6ac4ade1032ea1411680a04592d87">WaitUntil</a> (TimeType timepoint)</td></tr>
<tr class="memdesc:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified time.  <a href="#aa8b6ac4ade1032ea1411680a04592d87">More...</a><br /></td></tr>
<tr class="separator:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7811af34bc57739faeefbf64415f819c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7811af34bc57739faeefbf64415f819c">WasStarted</a> (void) volatile const </td></tr>
<tr class="memdesc:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable was ever started. <br /></td></tr>
<tr class="separator:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac55eff07f09e3c0c62fe31f21def134d"><td class="memItemLeft" align="right" valign="top">autowiring::AutoFilterDescriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet_factory.html#ac55eff07f09e3c0c62fe31f21def134d">GetTypeDescriptorUnsafe</a> (auto_id nodeType)</td></tr>
<tr class="memdesc:ac55eff07f09e3c0c62fe31f21def134d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a description of the AutoFilter associated with the type nodeType  <a href="#ac55eff07f09e3c0c62fe31f21def134d">More...</a><br /></td></tr>
<tr class="separator:ac55eff07f09e3c0c62fe31f21def134d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_core_runnable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_core_runnable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_core_runnable.html">CoreRunnable</a></td></tr>
<tr class="memitem:a7d2c7498d9db4e8f76dc2b6a69d8f1bc inherit pro_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; CoreObject &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7d2c7498d9db4e8f76dc2b6a69d8f1bc">GetOutstanding</a> (void) const </td></tr>
<tr class="separator:a7d2c7498d9db4e8f76dc2b6a69d8f1bc inherit pro_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A configurable factory class for pipeline packets with a built-in object pool </p>
<p>Generally, only one packet factory is required per context. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4ab0b5522e86a18ae648c1fdc2995ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const autowiring::AutoFilterDescriptor&amp; AutoPacketFactory::AddSubscriber </td>
          <td>(</td>
          <td class="paramtype">const autowiring::AutoFilterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the passed subscriber, if it defines a method called AutoFilter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The descriptor for the AutoFilter to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rhs</dd></dl>
<p>This method is idempotent </p>

</div>
</div>
<a class="anchor" id="a05639d9fca94f18e9f6f01ba5ad00b76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">autowiring::AutoFilterDescriptor AutoPacketFactory::AddSubscriber </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience override of AddSubscriber </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>A shared pointer to a type which has an AutoFilter routine on it</td></tr>
  </table>
  </dd>
</dl>
<p>For this call to be valid, T::AutoFilter must be defined and must be a compliant AutoFilter </p>

</div>
</div>
<a class="anchor" id="a5c26425753556533cdec00968acdcffa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::AppendAutoFiltersTo </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the internal set of AutoFilter members to the specified container </p>

</div>
</div>
<a class="anchor" id="a7f6df86d37b611fd7da03b5d89088d4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::Clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes this <a class="el" href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool ">AutoPacketFactory</a> to release all of its packet subscribers </p>
<p>This method will cause the factory to enter the Stopped state, if it's not there already. This method is idempotent. </p>

</div>
</div>
<a class="anchor" id="a5c82c3395752edb771d858183c22dbce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">autowiring::SatCounter* AutoPacketFactory::CreateSatCounterList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a linked list of saturation counters </p>
<dl class="section return"><dt>Returns</dt><dd>The first element in the list, or nullptr if the list is empty</dd></dl>

</div>
</div>
<a class="anchor" id="a7ec111268055a58305cb0f8b582b73e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_auto_packet.html">AutoPacket</a>&gt; AutoPacketFactory::CurrentPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The most recently issued packet, or possibly nullptr if that packet has already been destroyed </dd></dl>

<p>Referenced by <a class="el" href="class_auto_packet_factory.html#aeaa544dce7f6f2174cf839a403c094ca">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="adcff2e0a4fd863f3a618973c6c5d6b3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::DoAdditionalWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untimed variant of DoAdditionalWait </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#af3c2a762acf2fd367f09fff1100231da">CoreRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="aa969b149c74e23e0ee708481ec90ec94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacketFactory::DoAdditionalWait </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked just before control is returned to the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wait succeeded, false if a timeout occurred</dd></dl>
<p>This virtual method provides implementors with a way to add further constraints to the wait operation beyond the condition variable held internally by this <a class="el" href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ...">CoreRunnable</a>.</p>
<p>This method must return true if the timeout is indefinite. </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#acfcf01282cf908f91218bfdd5601678c">CoreRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="af8a8ae4780b5a7eb3bbcbaa5ba85c9d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;autowiring::AutoFilterDescriptor&gt; AutoPacketFactory::GetAutoFilters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A copy of all AutoFilter instances on this class </dd></dl>

</div>
</div>
<a class="anchor" id="aa14ee291b0bdb1c8131f268c4a7265c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AutoPacketFactory::GetMeanPacketLifetime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mean lifespan of AutoPackets in nanoseconds since the last statistics reset. </p>
<p>If the factory is left to run for an extended period of time without a reset the mean will decrease erroneously due to saturation of the accumulator. </p>

</div>
</div>
<a class="anchor" id="a8743ffc532d0fe739782a2f843a86467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AutoPacketFactory::GetPacketLifetimeStandardDeviation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of the lifespans of AutoPackets in nanoseconds since most recent statistics reset. </p>
<p>If the factory is left to run for an extended period of time without a reset the standard deviation will behave erraticly due to saturation of the accumulators. </p>

</div>
</div>
<a class="anchor" id="a002ce21f9b397665baa809d20fcdb6eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long AutoPacketFactory::GetTotalPacketCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of packets which have recorded duration statistics since the most recent statistics reset. </p>

</div>
</div>
<a class="anchor" id="ac55eff07f09e3c0c62fe31f21def134d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">autowiring::AutoFilterDescriptor AutoPacketFactory::GetTypeDescriptorUnsafe </td>
          <td>(</td>
          <td class="paramtype">auto_id&#160;</td>
          <td class="paramname"><em>nodeType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a description of the AutoFilter associated with the type nodeType </p>
<p>If a matching description was not found GetTypeDescriptor(type).GetAutoFilterTypeInfo() == nullptr </p>

<p>Referenced by <a class="el" href="class_auto_packet_factory.html#aeaa544dce7f6f2174cf839a403c094ca">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="adddbad76bc70d641a05fcccc4643be20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_auto_packet.html">AutoPacket</a>&gt; AutoPacketFactory::NewPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a new packet from the object pool and configures it with the current satisfaction graph </p>

<p>Referenced by <a class="el" href="class_auto_packet_factory.html#aeaa544dce7f6f2174cf839a403c094ca">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="aa60dd197a5520d5b06b1a1c9bfa8dda9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacketFactory::OnStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by the <a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12" title="Causes this runnable to begin processing. ">Start()</a> method. Override this method to perform any needed setup </p>
<dl class="section return"><dt>Returns</dt><dd>True if processing has started, false otherwise. When overriding, returning false will shut down the runnable immediately. </dd></dl>
<p>This method will be called at most once. Returning false from this method will result in an immediate invocation of OnStop(false). </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#aa72398f9348bd2b63fd9e040ee21f7e9">CoreRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="ac8615d15ffbe346e4f2f6976e8f4dcdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::OnStop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graceful</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Override this method to perform any needed cleanup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graceful</td><td>Specifies whether the runnable should stop normally or whether it should exit as quickly as possible. </td></tr>
  </table>
  </dd>
</dl>
<p>This method will be called at most once from a passive level. </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#ac2b1fc01ebff2aa052c13abe7be0d647">CoreRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="aeaa544dce7f6f2174cf839a403c094ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">autowiring::AutoFilterDescriptor AutoPacketFactory::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convienance overload of operator+= to add a subscriber from a lambda </p>
<p>This method provides a way to attach a lambda function directly to the factory </p>

</div>
</div>
<a class="anchor" id="ad58f46cdcfa605b2dbed77b96824fdf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::operator-= </td>
          <td>(</td>
          <td class="paramtype">const autowiring::AutoFilterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded counterpart to RemoveSubscriber </p>

<p>Referenced by <a class="el" href="class_auto_packet_factory.html#aeaa544dce7f6f2174cf839a403c094ca">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="ad98c3ea149c6c3edf0d2d647012d884f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::RecordPacketDuration </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by each <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>'s Finalize method to allow the factory to record statistics about packet lifespan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The total lifetime of the <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> that is being Finalized </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_auto_packet_factory.html#aeaa544dce7f6f2174cf839a403c094ca">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8c9683a9cea604f88986114920ae2c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::RemoveSubscriber </td>
          <td>(</td>
          <td class="paramtype">const autowiring::AutoFilterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>autoFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the designated AutoFilter from this factory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoFilter</td><td>The AutoFilter to be removed</td></tr>
  </table>
  </dd>
</dl>
<p>This method will not retroactively modify packets that have already been issued with the specified AutoFilter on it. Only packets that are issued after this method returns will lack the presence of the autoFilter described by the parameter. </p>

</div>
</div>
<a class="anchor" id="ae582e1a1e37dae158b22ec0ad322b7d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacketFactory::ResetPacketStatistics </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the statistics accumulators stored by the <a class="el" href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool ">AutoPacketFactory</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/autowiring/<a class="el" href="_auto_packet_factory_8h_source.html">AutoPacketFactory.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_auto_packet_factory.html">AutoPacketFactory</a></li>
    <li class="footer">Generated on Fri Jul 29 2016 21:26:22 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
