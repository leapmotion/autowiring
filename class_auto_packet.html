<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: AutoPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.7.6</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_auto_packet.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="class_auto_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AutoPacket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A decorator-style processing packet  
 <a href="class_auto_packet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a>&gt;</code></p>

<p>Inherits enable_shared_from_this&lt; AutoPacket &gt;, and TeardownNotifier.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a125a001b0cfb8f5bfca5cac6b291e2a9"><td class="memItemLeft" align="right" valign="top">const SatCounter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a125a001b0cfb8f5bfca5cac6b291e2a9">AddRecipient</a> (const AutoFilterDescriptor &amp;descriptor)</td></tr>
<tr class="memdesc:a125a001b0cfb8f5bfca5cac6b291e2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a recipient for data associated only with this issuance of the packet.  <a href="#a125a001b0cfb8f5bfca5cac6b291e2a9">More...</a><br /></td></tr>
<tr class="separator:a125a001b0cfb8f5bfca5cac6b291e2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bb862c699be8294d84d667a717c47f"><td class="memTemplParams" colspan="2">template&lt;typename... InArgs, typename... Outputs&gt; </td></tr>
<tr class="memitem:a41bb862c699be8294d84d667a717c47f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a41bb862c699be8294d84d667a717c47f">Call</a> (void(*pfn)(InArgs...), Outputs &amp;...outputs)</td></tr>
<tr class="memdesc:a41bb862c699be8294d84d667a717c47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the specified function as though it were an AutoFilter on this packet  <a href="#a41bb862c699be8294d84d667a717c47f">More...</a><br /></td></tr>
<tr class="separator:a41bb862c699be8294d84d667a717c47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1a71116512ef135baf225fdd91159"><td class="memTemplParams" colspan="2">template&lt;typename Fx , typename... InArgs, typename... Outputs&gt; </td></tr>
<tr class="memitem:a3af1a71116512ef135baf225fdd91159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a3af1a71116512ef135baf225fdd91159">Call</a> (Fx &amp;&amp;fx, void(Fx::*memfn)(InArgs...) const, Outputs &amp;...outputs)</td></tr>
<tr class="memdesc:a3af1a71116512ef135baf225fdd91159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a particular member function on the specified function object  <a href="#a3af1a71116512ef135baf225fdd91159">More...</a><br /></td></tr>
<tr class="separator:a3af1a71116512ef135baf225fdd91159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd590b15f2a72b483bf6a64022ff9b6e"><td class="memTemplParams" colspan="2">template&lt;typename Fx , typename... Outputs&gt; </td></tr>
<tr class="memitem:abd590b15f2a72b483bf6a64022ff9b6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#abd590b15f2a72b483bf6a64022ff9b6e">Call</a> (Fx &amp;&amp;fx, Outputs &amp;...outputs)</td></tr>
<tr class="memdesc:abd590b15f2a72b483bf6a64022ff9b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the specified function as though it were an AutoFilter on this packet  <a href="#abd590b15f2a72b483bf6a64022ff9b6e">More...</a><br /></td></tr>
<tr class="separator:abd590b15f2a72b483bf6a64022ff9b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3964c80db7d3f4a22584a7e3fa82e126"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3964c80db7d3f4a22584a7e3fa82e126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a3964c80db7d3f4a22584a7e3fa82e126">Decorate</a> (const std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="separator:a3964c80db7d3f4a22584a7e3fa82e126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eb82a4b2b0904f63d6d2a56639668c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab2eb82a4b2b0904f63d6d2a56639668c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ab2eb82a4b2b0904f63d6d2a56639668c">Decorate</a> (const std::shared_ptr&lt; const T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ab2eb82a4b2b0904f63d6d2a56639668c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decoration method specialized for const shared pointer types  <a href="#ab2eb82a4b2b0904f63d6d2a56639668c">More...</a><br /></td></tr>
<tr class="separator:ab2eb82a4b2b0904f63d6d2a56639668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226d8fca104604bf290251b30783d030"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a226d8fca104604bf290251b30783d030"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !autowiring::is_shared_ptr&lt; T &gt;::value, const T &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a226d8fca104604bf290251b30783d030">Decorate</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:a226d8fca104604bf290251b30783d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates this packet with a particular type  <a href="#a226d8fca104604bf290251b30783d030">More...</a><br /></td></tr>
<tr class="separator:a226d8fca104604bf290251b30783d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate</a> (const T &amp;immed, const Ts &amp;...immeds)</td></tr>
<tr class="memdesc:ac016b40fd64cf3e9df03627de240448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method  <a href="#ac016b40fd64cf3e9df03627de240448a">More...</a><br /></td></tr>
<tr class="separator:ac016b40fd64cf3e9df03627de240448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada270350032ac870594ac2fdf6fe372"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aada270350032ac870594ac2fdf6fe372"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aada270350032ac870594ac2fdf6fe372">DEPRECATED</a> (Unsatisfiable(void),&quot;Unsatisfiable is deprecated; use <a class="el" href="class_auto_packet.html#a29f7dcf03fe916c5566ca61afcc19782">MarkUnsatisfiable</a> instead.&quot;)</td></tr>
<tr class="memdesc:aada270350032ac870594ac2fdf6fe372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the named decoration as unsatisfiable  <a href="#aada270350032ac870594ac2fdf6fe372">More...</a><br /></td></tr>
<tr class="separator:aada270350032ac870594ac2fdf6fe372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d43caac6380f61c837c4baa2756d9c"><td class="memTemplParams" colspan="2">template&lt;class T , typename... Args&gt; </td></tr>
<tr class="memitem:af7d43caac6380f61c837c4baa2756d9c"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#af7d43caac6380f61c837c4baa2756d9c">Emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:af7d43caac6380f61c837c4baa2756d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates this packet with a particular type T, forwarding the arguments to the constructor of T.  <a href="#af7d43caac6380f61c837c4baa2756d9c">More...</a><br /></td></tr>
<tr class="separator:af7d43caac6380f61c837c4baa2756d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a92e6f29f23e8f301266dbb4461bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a04a92e6f29f23e8f301266dbb4461bd1">ForwardAll</a> (const std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt; &amp;recipient) const </td></tr>
<tr class="memdesc:a04a92e6f29f23e8f301266dbb4461bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares all broadcast data from this packet with the recipient packet <a href="#a04a92e6f29f23e8f301266dbb4461bd1">More...</a><br /></td></tr>
<tr class="separator:a04a92e6f29f23e8f301266dbb4461bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#afc2ea2311961fd3e9f92c6b5dc40887d">Get</a> (int tshift=0) const </td></tr>
<tr class="memdesc:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the desired type, or throws an exception if such a type cannot be found  <a href="#afc2ea2311961fd3e9f92c6b5dc40887d">More...</a><br /></td></tr>
<tr class="separator:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cde58980c81a1c47cd683dd820ff2b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a43cde58980c81a1c47cd683dd820ff2b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a43cde58980c81a1c47cd683dd820ff2b">Get</a> (const T *&amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:a43cde58980c81a1c47cd683dd820ff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this pipeline packet contains an entry of the specified type  <a href="#a43cde58980c81a1c47cd683dd820ff2b">More...</a><br /></td></tr>
<tr class="separator:a43cde58980c81a1c47cd683dd820ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c55fd5996f492dfa2d2ce68448fb67"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a39c55fd5996f492dfa2d2ce68448fb67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a39c55fd5996f492dfa2d2ce68448fb67">Get</a> (const std::shared_ptr&lt; T &gt; *&amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:a39c55fd5996f492dfa2d2ce68448fb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer specialization of const T*&amp;, used to obtain the underlying shared pointer for some type T  <a href="#a39c55fd5996f492dfa2d2ce68448fb67">More...</a><br /></td></tr>
<tr class="separator:a39c55fd5996f492dfa2d2ce68448fb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434994156ef4debce252bb124ba2d5e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a434994156ef4debce252bb124ba2d5e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a434994156ef4debce252bb124ba2d5e7">Get</a> (std::shared_ptr&lt; const T &gt; &amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:a434994156ef4debce252bb124ba2d5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer specialization, used to obtain the underlying shared pointer for some type T  <a href="#a434994156ef4debce252bb124ba2d5e7">More...</a><br /></td></tr>
<tr class="separator:a434994156ef4debce252bb124ba2d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3fb6084dc850b1b9d077726104541f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7b3fb6084dc850b1b9d077726104541f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; const T *[]&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a7b3fb6084dc850b1b9d077726104541f">GetAll</a> (int tshift=0) const </td></tr>
<tr class="memdesc:a7b3fb6084dc850b1b9d077726104541f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a null-terminated buffer containing all decorations  <a href="#a7b3fb6084dc850b1b9d077726104541f">More...</a><br /></td></tr>
<tr class="separator:a7b3fb6084dc850b1b9d077726104541f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83083664deb879a30addd33b1e69230c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a83083664deb879a30addd33b1e69230c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; std::shared_ptr&lt; const T &gt;[]&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a83083664deb879a30addd33b1e69230c">GetAllShared</a> (int tshift=0) const </td></tr>
<tr class="memdesc:a83083664deb879a30addd33b1e69230c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared variant of GetAll  <a href="#a83083664deb879a30addd33b1e69230c">More...</a><br /></td></tr>
<tr class="separator:a83083664deb879a30addd33b1e69230c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab194d4255c47b1d85d9b8b27a14f3f07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab194d4255c47b1d85d9b8b27a14f3f07"></a>
std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ab194d4255c47b1d85d9b8b27a14f3f07">GetContext</a> (void) const </td></tr>
<tr class="memdesc:ab194d4255c47b1d85d9b8b27a14f3f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context of this packet (The context of the <a class="el" href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool ">AutoPacketFactory</a> that created this context) <br /></td></tr>
<tr class="separator:ab194d4255c47b1d85d9b8b27a14f3f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1235227e171d7229b72d3901e6d1042"><td class="memItemLeft" align="right" valign="top">t_decorationMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aa1235227e171d7229b72d3901e6d1042">GetDecorations</a> (void) const </td></tr>
<tr class="separator:aa1235227e171d7229b72d3901e6d1042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad162cefce3bd9980fa2984c29f2a2517"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ad162cefce3bd9980fa2984c29f2a2517">GetDecorationTypeCount</a> (void) const </td></tr>
<tr class="separator:ad162cefce3bd9980fa2984c29f2a2517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8152052798e49283c8297886c62ffe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e8152052798e49283c8297886c62ffe"><td class="memTemplItemLeft" align="right" valign="top">const SatCounter &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction</a> (void) const </td></tr>
<tr class="separator:a1e8152052798e49283c8297886c62ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5467f83887d63a602cb05d88c6893bc0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5467f83887d63a602cb05d88c6893bc0"><td class="memTemplItemLeft" align="right" valign="top">const std::shared_ptr&lt; const T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a5467f83887d63a602cb05d88c6893bc0">GetShared</a> (int tshift=0) const </td></tr>
<tr class="separator:a5467f83887d63a602cb05d88c6893bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749ec811977357ea7165b8e77be65932"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a749ec811977357ea7165b8e77be65932"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a749ec811977357ea7165b8e77be65932">Has</a> (int tshift=0) const </td></tr>
<tr class="separator:a749ec811977357ea7165b8e77be65932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fe26e212e7ca42fa6731f9a168111a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14fe26e212e7ca42fa6731f9a168111a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14fe26e212e7ca42fa6731f9a168111a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a14fe26e212e7ca42fa6731f9a168111a">HasPublishers</a> (void) const </td></tr>
<tr class="memdesc:a14fe26e212e7ca42fa6731f9a168111a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>Zero if there are no publishers, otherwise the number of publishers</dd></dl>
<br /></td></tr>
<tr class="separator:a14fe26e212e7ca42fa6731f9a168111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76af6d953ba5968fffd20cb736ad0cbc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a76af6d953ba5968fffd20cb736ad0cbc">HasSubscribers</a> (void) const </td></tr>
<tr class="memdesc:a76af6d953ba5968fffd20cb736ad0cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if the indicated type has been requested for use by some consumer</dd></dl>
<br /></td></tr>
<tr class="separator:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37079ae44f1bea32350e8ea93b12ec28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a37079ae44f1bea32350e8ea93b12ec28">IsUnsatisfiable</a> (const auto_id &amp;id) const </td></tr>
<tr class="separator:a37079ae44f1bea32350e8ea93b12ec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c97deb0563443453c6c0407a13a525"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a48c97deb0563443453c6c0407a13a525"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a48c97deb0563443453c6c0407a13a525">MarkUnsatisfiable</a> (void)</td></tr>
<tr class="memdesc:a48c97deb0563443453c6c0407a13a525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the named decoration as unsatisfiable  <a href="#a48c97deb0563443453c6c0407a13a525">More...</a><br /></td></tr>
<tr class="separator:a48c97deb0563443453c6c0407a13a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa96738dac77521d123698ad3f80a35"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a3fa96738dac77521d123698ad3f80a35"><td class="memTemplItemLeft" align="right" valign="top">const SatCounter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a3fa96738dac77521d123698ad3f80a35">operator+=</a> (Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a3fa96738dac77521d123698ad3f80a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload, identical in behavior to AddRecipient  <a href="#a3fa96738dac77521d123698ad3f80a35">More...</a><br /></td></tr>
<tr class="separator:a3fa96738dac77521d123698ad3f80a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a84b4131245539806ff5a7738f04f3"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a30a84b4131245539806ff5a7738f04f3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_auto_packet.html">AutoPacket</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a30a84b4131245539806ff5a7738f04f3">operator+=</a> (Fx &amp;&amp;fx) const </td></tr>
<tr class="memdesc:a30a84b4131245539806ff5a7738f04f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload, provided to allow the attachment of receive-only filters to a const <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>  <a href="#a30a84b4131245539806ff5a7738f04f3">More...</a><br /></td></tr>
<tr class="separator:a30a84b4131245539806ff5a7738f04f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa302c91a39594f5ea0f58094ce4fea3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aa302c91a39594f5ea0f58094ce4fea3a">RemoveRecipient</a> (const SatCounter &amp;recipient)</td></tr>
<tr class="memdesc:aa302c91a39594f5ea0f58094ce4fea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added packet recipient  <a href="#aa302c91a39594f5ea0f58094ce4fea3a">More...</a><br /></td></tr>
<tr class="separator:aa302c91a39594f5ea0f58094ce4fea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e7dd1ee400c313c05d56d7642a0c87"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a99e7dd1ee400c313c05d56d7642a0c87">Successor</a> (void)</td></tr>
<tr class="memdesc:a99e7dd1ee400c313c05d56d7642a0c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next packet that will be issued by the packet factory in this context relative to this context  <a href="#a99e7dd1ee400c313c05d56d7642a0c87">More...</a><br /></td></tr>
<tr class="separator:a99e7dd1ee400c313c05d56d7642a0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24353583ddd518aad7973942e4b1baa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ac24353583ddd518aad7973942e4b1baa">Wait</a> (std::condition_variable &amp;cv, const AutoFilterArgument *inputs, std::chrono::nanoseconds duration=std::chrono::nanoseconds::max())</td></tr>
<tr class="memdesc:ac24353583ddd518aad7973942e4b1baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the specified descriptor is satisfied  <a href="#ac24353583ddd518aad7973942e4b1baa">More...</a><br /></td></tr>
<tr class="separator:ac24353583ddd518aad7973942e4b1baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde180a2515100943e2b33e999b7f6d3"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:adde180a2515100943e2b33e999b7f6d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#adde180a2515100943e2b33e999b7f6d3">Wait</a> (std::condition_variable &amp;cv, Fx &amp;&amp;autoFilter, std::chrono::nanoseconds duration=std::chrono::nanoseconds::max())</td></tr>
<tr class="memdesc:adde180a2515100943e2b33e999b7f6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the passed lambda function can be called  <a href="#adde180a2515100943e2b33e999b7f6d3">More...</a><br /></td></tr>
<tr class="separator:adde180a2515100943e2b33e999b7f6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5587ee9febad91417f6ee1f4c65d6282"><td class="memTemplParams" colspan="2">template&lt;class... Decorations&gt; </td></tr>
<tr class="memitem:a5587ee9febad91417f6ee1f4c65d6282"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a5587ee9febad91417f6ee1f4c65d6282">Wait</a> (std::condition_variable &amp;cv)</td></tr>
<tr class="memdesc:a5587ee9febad91417f6ee1f4c65d6282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays until the specified decorations are satisfied  <a href="#a5587ee9febad91417f6ee1f4c65d6282">More...</a><br /></td></tr>
<tr class="separator:a5587ee9febad91417f6ee1f4c65d6282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0b8aea3ddb3ab167ec745f5f7cb6dd3a">Wait</a> (std::chrono::nanoseconds duration, std::condition_variable &amp;cv)</td></tr>
<tr class="memdesc:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed version of Wait  <a href="#a0b8aea3ddb3ab167ec745f5f7cb6dd3a">More...</a><br /></td></tr>
<tr class="separator:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3431dd52847bf0fcc2e2388a80793882"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_auto_packet.html">AutoPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a3431dd52847bf0fcc2e2388a80793882">ClearCurrent</a> (void)</td></tr>
<tr class="memdesc:a3431dd52847bf0fcc2e2388a80793882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the current <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> pointer  <a href="#a3431dd52847bf0fcc2e2388a80793882">More...</a><br /></td></tr>
<tr class="separator:a3431dd52847bf0fcc2e2388a80793882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01fa9d5bb18947361ae6ebae940db9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_auto_packet.html">AutoPacket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ae01fa9d5bb18947361ae6ebae940db9c">CurrentPacket</a> (void)</td></tr>
<tr class="memdesc:ae01fa9d5bb18947361ae6ebae940db9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current packet being processed by an AutoFilter  <a href="#ae01fa9d5bb18947361ae6ebae940db9c">More...</a><br /></td></tr>
<tr class="separator:ae01fa9d5bb18947361ae6ebae940db9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b84b07693afab6a7ba2621c389f4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_auto_packet.html">AutoPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a269b84b07693afab6a7ba2621c389f4c">SetCurrent</a> (<a class="el" href="class_auto_packet.html">AutoPacket</a> *apkt)</td></tr>
<tr class="memdesc:a269b84b07693afab6a7ba2621c389f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> pointer  <a href="#a269b84b07693afab6a7ba2621c389f4c">More...</a><br /></td></tr>
<tr class="separator:a269b84b07693afab6a7ba2621c389f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a684e3e0747beb2f1d052e6e46f9da931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a684e3e0747beb2f1d052e6e46f9da931">AddSatCounterUnsafe</a> (SatCounter &amp;satCounter)</td></tr>
<tr class="memdesc:a684e3e0747beb2f1d052e6e46f9da931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all AutoFilter argument information for a recipient  <a href="#a684e3e0747beb2f1d052e6e46f9da931">More...</a><br /></td></tr>
<tr class="separator:a684e3e0747beb2f1d052e6e46f9da931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cab6182ed3149b78b023a303467d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a58cab6182ed3149b78b023a303467d39">Decorate</a> (const AnySharedPointer &amp;ptr, DecorationKey key)</td></tr>
<tr class="memdesc:a58cab6182ed3149b78b023a303467d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime counterpart to Decorate <a href="#a58cab6182ed3149b78b023a303467d39">More...</a><br /></td></tr>
<tr class="separator:a58cab6182ed3149b78b023a303467d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff5b7454dc3bcfb943d74e8738efe72"><td class="memItemLeft" align="right" valign="top">DecorationDisposition &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#afff5b7454dc3bcfb943d74e8738efe72">DecorateImmediateUnsafe</a> (const DecorationKey &amp;key, const void *pvImmed)</td></tr>
<tr class="memdesc:afff5b7454dc3bcfb943d74e8738efe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks out the decoration named by the specified type information and attaches the specified immediate pointer to it  <a href="#afff5b7454dc3bcfb943d74e8738efe72">More...</a><br /></td></tr>
<tr class="separator:afff5b7454dc3bcfb943d74e8738efe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721c9e5f19dcc05c8d408901615fcea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a721c9e5f19dcc05c8d408901615fcea5">DecorateNoPriors</a> (const AnySharedPointer &amp;ptr, DecorationKey key)</td></tr>
<tr class="memdesc:a721c9e5f19dcc05c8d408901615fcea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a decoration operation but does not attach priors to successors.  <a href="#a721c9e5f19dcc05c8d408901615fcea5">More...</a><br /></td></tr>
<tr class="separator:a721c9e5f19dcc05c8d408901615fcea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ffd3b386863a7874866aa5a6b0429"><td class="memItemLeft" align="right" valign="top">const DecorationDisposition *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#af40ffd3b386863a7874866aa5a6b0429">GetDisposition</a> (const DecorationKey &amp;ti) const </td></tr>
<tr class="memdesc:af40ffd3b386863a7874866aa5a6b0429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the decoration disposition corresponding to some type  <a href="#af40ffd3b386863a7874866aa5a6b0429">More...</a><br /></td></tr>
<tr class="separator:af40ffd3b386863a7874866aa5a6b0429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ae91a9e5cffb39e45ca872a380d68f"><td class="memItemLeft" align="right" valign="top">const SatCounter &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#af7ae91a9e5cffb39e45ca872a380d68f">GetSatisfaction</a> (auto_id subscriber) const </td></tr>
<tr class="separator:af7ae91a9e5cffb39e45ca872a380d68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfb5eab55e752d335a5844b32ebbc34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedfb5eab55e752d335a5844b32ebbc34"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aedfb5eab55e752d335a5844b32ebbc34">HasPublishers</a> (const DecorationKey &amp;key) const </td></tr>
<tr class="memdesc:aedfb5eab55e752d335a5844b32ebbc34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>Zero if there are no publishers, otherwise the number of publishers</dd></dl>
<br /></td></tr>
<tr class="separator:aedfb5eab55e752d335a5844b32ebbc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a520b94e0c318d3fb57b921aa4c0fe55d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a520b94e0c318d3fb57b921aa4c0fe55d">HasSubscribers</a> (const DecorationKey &amp;key) const </td></tr>
<tr class="memdesc:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if the indicated type has been requested for use by some consumer</dd></dl>
<br /></td></tr>
<tr class="separator:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758dc93f396121900cc5de17f46dcbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0758dc93f396121900cc5de17f46dcbf">HasUnsafe</a> (const DecorationKey &amp;key) const </td></tr>
<tr class="memdesc:a0758dc93f396121900cc5de17f46dcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsynchronized runtime counterpart to Has <a href="#a0758dc93f396121900cc5de17f46dcbf">More...</a><br /></td></tr>
<tr class="separator:a0758dc93f396121900cc5de17f46dcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bf152b18a9e20c701661706fcce9c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a64bf152b18a9e20c701661706fcce9c9">MarkSuccessorsUnsatisfiable</a> (DecorationKey type)</td></tr>
<tr class="memdesc:a64bf152b18a9e20c701661706fcce9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks timeshifted decorations on successor packets as unsatisfiable  <a href="#a64bf152b18a9e20c701661706fcce9c9">More...</a><br /></td></tr>
<tr class="separator:a64bf152b18a9e20c701661706fcce9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f7dcf03fe916c5566ca61afcc19782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a29f7dcf03fe916c5566ca61afcc19782">MarkUnsatisfiable</a> (const DecorationKey &amp;key)</td></tr>
<tr class="memdesc:a29f7dcf03fe916c5566ca61afcc19782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the specified entry as being unsatisfiable  <a href="#a29f7dcf03fe916c5566ca61afcc19782">More...</a><br /></td></tr>
<tr class="separator:a29f7dcf03fe916c5566ca61afcc19782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e257b9636aff04f23d82d11abfb2a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a17e257b9636aff04f23d82d11abfb2a6">PulseSatisfactionUnsafe</a> (std::unique_lock&lt; std::mutex &gt; lk, DecorationDisposition *pTypeSubs[], size_t nInfos)</td></tr>
<tr class="memdesc:a17e257b9636aff04f23d82d11abfb2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a "satisfaction pulse", which will avoid notifying any deferred filters  <a href="#a17e257b9636aff04f23d82d11abfb2a6">More...</a><br /></td></tr>
<tr class="separator:a17e257b9636aff04f23d82d11abfb2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d82f8536c4a1b847a5ba0efb9b99d6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#af7d82f8536c4a1b847a5ba0efb9b99d6">SuccessorUnsafe</a> (void)</td></tr>
<tr class="memdesc:af7d82f8536c4a1b847a5ba0efb9b99d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The portion of Successor that must run under a lock  <a href="#af7d82f8536c4a1b847a5ba0efb9b99d6">More...</a><br /></td></tr>
<tr class="separator:af7d82f8536c4a1b847a5ba0efb9b99d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5500ce562229a4b8944a0f7a647d0ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a5500ce562229a4b8944a0f7a647d0ab6">UpdateSatisfactionUnsafe</a> (std::unique_lock&lt; std::mutex &gt; lk, const DecorationDisposition &amp;disposition)</td></tr>
<tr class="memdesc:a5500ce562229a4b8944a0f7a647d0ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates subscriber statuses given that the specified type information has been satisfied  <a href="#a5500ce562229a4b8944a0f7a647d0ab6">More...</a><br /></td></tr>
<tr class="separator:a5500ce562229a4b8944a0f7a647d0ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a876a04e499194ec2c8960ee9aa655b0b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a876a04e499194ec2c8960ee9aa655b0b">ThrowMultiplyDecoratedException</a> (const DecorationKey &amp;key)</td></tr>
<tr class="memdesc:a876a04e499194ec2c8960ee9aa655b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a formatted runtime error corresponding to the case where a decoration was demanded and more than one such decoration was present  <a href="#a876a04e499194ec2c8960ee9aa655b0b">More...</a><br /></td></tr>
<tr class="separator:a876a04e499194ec2c8960ee9aa655b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77d4e6ff2c9fe5fb19dcd43c91fbc57"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ad77d4e6ff2c9fe5fb19dcd43c91fbc57">ThrowNotDecoratedException</a> (const DecorationKey &amp;key)</td></tr>
<tr class="memdesc:ad77d4e6ff2c9fe5fb19dcd43c91fbc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a formatted runtime error corresponding to the case where an absent decoration was demanded  <a href="#ad77d4e6ff2c9fe5fb19dcd43c91fbc57">More...</a><br /></td></tr>
<tr class="separator:ad77d4e6ff2c9fe5fb19dcd43c91fbc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A decorator-style processing packet </p>
<p>A processing packet may be decorated with additional types as desired by the user. The pipeline packet is not a type of context; querying the packet for an element of a particular type will look for an element of precisely that type, not an inherited type or a related interface. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a125a001b0cfb8f5bfca5cac6b291e2a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter* AutoPacket::AddRecipient </td>
          <td>(</td>
          <td class="paramtype">const AutoFilterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a recipient for data associated only with this issuance of the packet. </p>
<p>This method is not idempotent. The returned Recipient structure may be used to remove the recipient safely at any point. The caller MUST NOT attempt </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a3fa96738dac77521d123698ad3f80a35">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="a684e3e0747beb2f1d052e6e46f9da931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::AddSatCounterUnsafe </td>
          <td>(</td>
          <td class="paramtype">SatCounter &amp;&#160;</td>
          <td class="paramname"><em>satCounter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all AutoFilter argument information for a recipient </p>

</div>
</div>
<a class="anchor" id="a41bb862c699be8294d84d667a717c47f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... InArgs, typename... Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Call </td>
          <td>(</td>
          <td class="paramtype">void(*)(InArgs...)&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outputs &amp;...&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the specified function as though it were an AutoFilter on this packet </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#abd590b15f2a72b483bf6a64022ff9b6e">Call()</a>.</p>

</div>
</div>
<a class="anchor" id="a3af1a71116512ef135baf225fdd91159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fx , typename... InArgs, typename... Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Call </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(Fx::*)(InArgs...) const&#160;</td>
          <td class="paramname"><em>memfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outputs &amp;...&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a particular member function on the specified function object </p>

</div>
</div>
<a class="anchor" id="abd590b15f2a72b483bf6a64022ff9b6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fx , typename... Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Call </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outputs &amp;...&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the specified function as though it were an AutoFilter on this packet </p>

</div>
</div>
<a class="anchor" id="a3431dd52847bf0fcc2e2388a80793882"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_auto_packet.html">AutoPacket</a>* AutoPacket::ClearCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the current <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> pointer </p>
<p>Identical to SetCurrent(nullptr) </p>

</div>
</div>
<a class="anchor" id="ae01fa9d5bb18947361ae6ebae940db9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_auto_packet.html">AutoPacket</a>&amp; AutoPacket::CurrentPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current packet being processed by an AutoFilter </p>
<p>It is an error to call this anywhere except from an AutoFilter routine </p>

</div>
</div>
<a class="anchor" id="a58cab6182ed3149b78b023a303467d39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">const AnySharedPointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecorationKey&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runtime counterpart to Decorate</p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a3964c80db7d3f4a22584a7e3fa82e126">Decorate()</a>, and <a class="el" href="class_auto_packet.html#af7d43caac6380f61c837c4baa2756d9c">Emplace()</a>.</p>

</div>
</div>
<a class="anchor" id="a3964c80db7d3f4a22584a7e3fa82e126"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Decoration method specialized for shared pointer types </p>
<p>This decoration method has the additional benefit that it will make direct use of the passed shared pointer.</p>
<p>If the passed value is null, the corresponding value will be marked unsatisfiable. </p>

</div>
</div>
<a class="anchor" id="ab2eb82a4b2b0904f63d6d2a56639668c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decoration method specialized for const shared pointer types </p>
<p>This decoration method has the additional benefit that it will make direct use of the passed shared pointer. </p>

</div>
</div>
<a class="anchor" id="a226d8fca104604bf290251b30783d030"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !autowiring::is_shared_ptr&lt;T&gt;::value, const T&amp; &gt;::type AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decorates this packet with a particular type </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the internally persisted object</dd></dl>
<p>The Decorate method is unconditional and will install the passed value regardless of whether any subscribers exist. </p>

</div>
</div>
<a class="anchor" id="ac016b40fd64cf3e9df03627de240448a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DecorateImmediate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>immed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>immeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method </p>
<p>Unlike Decorate, the arguments of DecorateImmediate are not copied. Each decoration is only valid for AutoFilters which are valid during this call. If multiple values are specified, all will be simultaneously made valid and then invalidated. </p>

</div>
</div>
<a class="anchor" id="afff5b7454dc3bcfb943d74e8738efe72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DecorationDisposition&amp; AutoPacket::DecorateImmediateUnsafe </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvImmed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks out the decoration named by the specified type information and attaches the specified immediate pointer to it </p>
<p>An immediate checkout differs from a standard checkout in that the internally held decoration is only temporarily available. Thus, callers are either satisfied at the point of decoration, or will not be satisfied for that type. </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate()</a>.</p>

</div>
</div>
<a class="anchor" id="a721c9e5f19dcc05c8d408901615fcea5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DecorateNoPriors </td>
          <td>(</td>
          <td class="paramtype">const AnySharedPointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecorationKey&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a decoration operation but does not attach priors to successors. </p>

</div>
</div>
<a class="anchor" id="aada270350032ac870594ac2fdf6fe372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">Unsatisfiable(void)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Unsatisfiable is deprecated; use <a class="el" href="class_auto_packet.html#a29f7dcf03fe916c5566ca61afcc19782">MarkUnsatisfiable</a> instead.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the named decoration as unsatisfiable </p>
<p>Marking a decoration as unsatisfiable immediately causes any filters with an input of the form std::shared_ptr&lt;const T&gt; to be called, if the remainder of their inputs are available. </p>

</div>
</div>
<a class="anchor" id="af7d43caac6380f61c837c4baa2756d9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decorates this packet with a particular type T, forwarding the arguments to the constructor of T. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the internally persisted object</dd></dl>
<p>The Decorate method is unconditional and will install the passed value regardless of whether any subscribers exist. </p>

</div>
</div>
<a class="anchor" id="a04a92e6f29f23e8f301266dbb4461bd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::ForwardAll </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shares all broadcast data from this packet with the recipient packet</p>
<p>This method should ONLY be called during the final-call sequence. This method is expected to be used to bridge data to a sibling context. Therefore, only broadcast data will be shared, since pipes between sibling contexts cannot be defined. Furthermore, types that are unsatisfied in this context will not be marked as unsatisfied in the recipient - only present data will be provided. </p>

</div>
</div>
<a class="anchor" id="afc2ea2311961fd3e9f92c6b5dc40887d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects the desired type, or throws an exception if such a type cannot be found </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a5467f83887d63a602cb05d88c6893bc0">GetShared()</a>.</p>

</div>
</div>
<a class="anchor" id="a43cde58980c81a1c47cd683dd820ff2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const T *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this pipeline packet contains an entry of the specified type </p>
<p>This method is also used by DecorateImmediate to extract pointers to data that is valid ONLY during recursive satisfaction calls. </p>

</div>
</div>
<a class="anchor" id="a39c55fd5996f492dfa2d2ce68448fb67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer specialization of const T*&amp;, used to obtain the underlying shared pointer for some type T </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Receives the requested decoration, or else nullptr</td></tr>
    <tr><td class="paramname">tshift</td><td>The number back to retrieve</td></tr>
  </table>
  </dd>
</dl>
<p>This specialization cannot be used to obtain a decoration which has been attached to this packet via DecorateImmediate.</p>
<p>This method will throw an exception if the requested decoration is multiply present on the packet </p>

</div>
</div>
<a class="anchor" id="a434994156ef4debce252bb124ba2d5e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer specialization, used to obtain the underlying shared pointer for some type T </p>
<p>This method can return an argument of DecorateImmediate as a shared_ptr&lt;T&gt; without a deleter. PROBLEM: This use case implies that holding shared_ptr references to decorations is NOT SAFE. </p>

</div>
</div>
<a class="anchor" id="a7b3fb6084dc850b1b9d077726104541f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const T*[]&gt; AutoPacket::GetAll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a null-terminated buffer containing all decorations </p>
<dl class="section return"><dt>Returns</dt><dd>The null-terminated buffer</dd></dl>

</div>
</div>
<a class="anchor" id="a83083664deb879a30addd33b1e69230c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::shared_ptr&lt;const T&gt;[]&gt; AutoPacket::GetAllShared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared variant of GetAll </p>
<dl class="section return"><dt>Returns</dt><dd>The null-terminated buffer</dd></dl>

</div>
</div>
<a class="anchor" id="aa1235227e171d7229b72d3901e6d1042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">t_decorationMap AutoPacket::GetDecorations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A copy of the decoration dispositions collection (this is really an implementation-detail-based description of the parameters of all relevant filters, including lambdas appended to this packet). </dd></dl>
<p>This is a diagnostic method, users are recommended to avoid the use of this routine where possible </p>

</div>
</div>
<a class="anchor" id="ad162cefce3bd9980fa2984c29f2a2517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t AutoPacket::GetDecorationTypeCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of distinct decoration types on this packet (this is really an implementation-detail-based count of the parameters of all relevant filters, including lambdas appended to this packet). </dd></dl>

</div>
</div>
<a class="anchor" id="af40ffd3b386863a7874866aa5a6b0429"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DecorationDisposition* AutoPacket::GetDisposition </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the decoration disposition corresponding to some type </p>
<dl class="section return"><dt>Returns</dt><dd>The disposition, if the decoration exists and is satisfied, otherwise nullptr</dd></dl>

<p>Referenced by <a class="el" href="class_auto_packet.html#a43cde58980c81a1c47cd683dd820ff2b">Get()</a>.</p>

</div>
</div>
<a class="anchor" id="af7ae91a9e5cffb39e45ca872a380d68f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter&amp; AutoPacket::GetSatisfaction </td>
          <td>(</td>
          <td class="paramtype">auto_id&#160;</td>
          <td class="paramname"><em>subscriber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
<p>If the type is not a subscriber <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction()</a>.GetType() == nullptr will be true </p>

</div>
</div>
<a class="anchor" id="a1e8152052798e49283c8297886c62ffe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter&amp; AutoPacket::GetSatisfaction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
<p>If the type is not a subscriber <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction()</a>.GetType() == nullptr will be true </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction()</a>.</p>

</div>
</div>
<a class="anchor" id="a5467f83887d63a602cb05d88c6893bc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;const T&gt;* AutoPacket::GetShared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The shared pointer decoration for the specified type and time shift, or nullptr if no such decoration exists </dd></dl>

</div>
</div>
<a class="anchor" id="a749ec811977357ea7165b8e77be65932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Has </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this packet posesses one or more instances of a decoration of the specified type </dd></dl>
<p>Although "AutoPacket &amp;" and "const AutoPacket&amp;" argument types will be satisfied, the <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> does not "have" these types. </p>

</div>
</div>
<a class="anchor" id="a0758dc93f396121900cc5de17f46dcbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::HasUnsafe </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsynchronized runtime counterpart to Has</p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a749ec811977357ea7165b8e77be65932">Has()</a>.</p>

</div>
</div>
<a class="anchor" id="a37079ae44f1bea32350e8ea93b12ec28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::IsUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype">const auto_id &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the specified type is unsatisfiable </dd></dl>

</div>
</div>
<a class="anchor" id="a64bf152b18a9e20c701661706fcce9c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::MarkSuccessorsUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype">DecorationKey&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks timeshifted decorations on successor packets as unsatisfiable </p>

</div>
</div>
<a class="anchor" id="a29f7dcf03fe916c5566ca61afcc19782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::MarkUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the specified entry as being unsatisfiable </p>

</div>
</div>
<a class="anchor" id="a48c97deb0563443453c6c0407a13a525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::MarkUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the named decoration as unsatisfiable </p>
<p>Marking a decoration as unsatisfiable immediately causes any filters with an input of the form std::shared_ptr&lt;const T&gt; to be called, if the remainder of their inputs are available. </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a3964c80db7d3f4a22584a7e3fa82e126">Decorate()</a>, and <a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fa96738dac77521d123698ad3f80a35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter* AutoPacket::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload, identical in behavior to AddRecipient </p>

</div>
</div>
<a class="anchor" id="a30a84b4131245539806ff5a7738f04f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_auto_packet.html">AutoPacket</a>&amp; AutoPacket::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload, provided to allow the attachment of receive-only filters to a const <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> </p>

</div>
</div>
<a class="anchor" id="a17e257b9636aff04f23d82d11abfb2a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::PulseSatisfactionUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt;&#160;</td>
          <td class="paramname"><em>lk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecorationDisposition *&#160;</td>
          <td class="paramname"><em>pTypeSubs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInfos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a "satisfaction pulse", which will avoid notifying any deferred filters </p>
<p>A satisfaction pulse will call any AutoFilter instances which are satisfied by the decoration of the passed decoration types. </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate()</a>.</p>

</div>
</div>
<a class="anchor" id="aa302c91a39594f5ea0f58094ce4fea3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::RemoveRecipient </td>
          <td>(</td>
          <td class="paramtype">const SatCounter &amp;&#160;</td>
          <td class="paramname"><em>recipient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a previously added packet recipient </p>

</div>
</div>
<a class="anchor" id="a269b84b07693afab6a7ba2621c389f4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_auto_packet.html">AutoPacket</a>* AutoPacket::SetCurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_auto_packet.html">AutoPacket</a> *&#160;</td>
          <td class="paramname"><em>apkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> pointer </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a3431dd52847bf0fcc2e2388a80793882">ClearCurrent()</a>.</p>

</div>
</div>
<a class="anchor" id="a99e7dd1ee400c313c05d56d7642a0c87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_auto_packet.html">AutoPacket</a>&gt; AutoPacket::Successor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next packet that will be issued by the packet factory in this context relative to this context </p>

</div>
</div>
<a class="anchor" id="af7d82f8536c4a1b847a5ba0efb9b99d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_auto_packet.html">AutoPacket</a>&gt; AutoPacket::SuccessorUnsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The portion of Successor that must run under a lock </p>

</div>
</div>
<a class="anchor" id="a876a04e499194ec2c8960ee9aa655b0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AutoPacket::ThrowMultiplyDecoratedException </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a formatted runtime error corresponding to the case where a decoration was demanded and more than one such decoration was present </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a43cde58980c81a1c47cd683dd820ff2b">Get()</a>.</p>

</div>
</div>
<a class="anchor" id="ad77d4e6ff2c9fe5fb19dcd43c91fbc57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AutoPacket::ThrowNotDecoratedException </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a formatted runtime error corresponding to the case where an absent decoration was demanded </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#afc2ea2311961fd3e9f92c6b5dc40887d">Get()</a>.</p>

</div>
</div>
<a class="anchor" id="a5500ce562229a4b8944a0f7a647d0ab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::UpdateSatisfactionUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt;&#160;</td>
          <td class="paramname"><em>lk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecorationDisposition &amp;&#160;</td>
          <td class="paramname"><em>disposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates subscriber statuses given that the specified type information has been satisfied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lk</td><td>The unique_lock used to control the synchronization level</td></tr>
    <tr><td class="paramname">disposition</td><td>The decoration that was just updated</td></tr>
  </table>
  </dd>
</dl>
<p>This method results in a call to the AutoFilter method on any subscribers which are satisfied by this decoration. This method must be called with m_lock held. </p>

</div>
</div>
<a class="anchor" id="ac24353583ddd518aad7973942e4b1baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AutoFilterArgument *&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::nanoseconds::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until the specified descriptor is satisfied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cv</td><td>A condition variable used to perform the wait</td></tr>
    <tr><td class="paramname">inputs</td><td>The inputs whose satisfaction state is to be considered</td></tr>
    <tr><td class="paramname">duration</td><td>The amount of time to wait. If set to std::chrono::nanoseconds::max, this method will block indefinitely </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if a timeout occurred, true otherwise</dd></dl>
<p>This method considers the arguments described by "inputs" and will block until all decorations that are needed by this filter have been satisfied on this packet. When this function returns, the specified filter will have been called. </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#adde180a2515100943e2b33e999b7f6d3">Wait()</a>.</p>

</div>
</div>
<a class="anchor" id="adde180a2515100943e2b33e999b7f6d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>autoFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::nanoseconds::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until the passed lambda function can be called </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cv</td><td>A condition variable that can be signalled when the wait condition has expired</td></tr>
    <tr><td class="paramname">autoFilter</td><td>The filter to be blocked on</td></tr>
    <tr><td class="paramname">duration</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false if a timeout occurred </dd></dl>
<p>This method will invoke the passed autoFilter function once all of its arguments are present on the packet this routine generates internally. This method will not return until the specified autoFilter is called. If the autoFilter cannot be called because the required decorations are not present on the packet on teardown, this method will throw an exception.</p>
<p>The passed autoFilter routine must not attach any decorations to the packet, nor may it accept a non-const AutoFilter as an input argument. </p>

</div>
</div>
<a class="anchor" id="a5587ee9febad91417f6ee1f4c65d6282"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Decorations&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delays until the specified decorations are satisfied </p>

</div>
</div>
<a class="anchor" id="a0b8aea3ddb3ab167ec745f5f7cb6dd3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timed version of Wait </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_auto_packet.html">AutoPacket</a></li>
    <li class="footer">Generated on Wed Jan 6 2016 16:27:05 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
