{
  "name": "ngmin",
  "description": "AngularJS Minifier",
  "version": "0.4.1",
  "author": {
    "name": "Brian Ford"
  },
  "license": "MIT",
  "main": "main.js",
  "dependencies": {
    "astral": "~0.1.0",
    "astral-angular-annotate": "~0.0.1",
    "escodegen": "~0.0.15",
    "esprima": "~1.0.2",
    "commander": "~1.1.1",
    "clone": "~0.1.6"
  },
  "devDependencies": {
    "should": "~1.2.1",
    "mocha": "~1.5.0"
  },
  "keywords": [
    "angularjs",
    "minifier"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/btford/ngmin"
  },
  "bin": {
    "ngmin": "./bin/ngmin"
  },
  "scripts": {
    "test": "mocha"
  },
  "readme": "# ngmin\n[![Build Status](https://travis-ci.org/btford/ngmin.png?branch=master)](https://travis-ci.org/btford/ngmin)\n\nngmin is an AngularJS application pre-minifier. The goal is ultimately to use this alongside yeoman and grunt to make developing and building Angular apps fast, easy, and fun.\n\n## tl;dr\nTurns this\n\n```\nangular.module('whatever').controller('MyCtrl', function ($scope, $http) { ... });\n```\n\ninto\n\n```\nangular.module('whatever').controller('MyCtrl', ['$scope', '$http', function ($scope, $http) { ... }]);\n```\n\nso that minifiers can handle AngularJS's DI annotations and you can save a few keystrokes.\n\n## Installation\nInstall via npm:\n```bash\nnpm install -g ngmin\n```\n\n## Build Systems\n\n- [grunt-ngmin](https://github.com/btford/grunt-ngmin)\n- [gulp-ngmin](https://github.com/sindresorhus/gulp-ngmin)\n\n## Asset Pipelines\n\n### Ruby on Rails\n\n`ngmin` is available for Rails via [`ngmin-rails`](http://rubygems.org/gems/ngmin-rails).\n\n### Clojure Ring\n\n`ngmin` is available for Clojure Ring via [`optimus-angular`](https://github.com/magnars/optimus-angular) as an [`Optimus`](https://github.com/magnars/optimus) asset middleware.\n\n## CLI Usage\n\nIdeally, you should concat all of your files, then run `ngmin` once on the concatenated file.\n\n```bash\nngmin somefile.js somefile.annotate.js\n```\n\nFrom here, the annotated file(s) to a minifier.\n\n`ngmin` also accepts stdio. The following is the same as above:\n\n```bash\nngmin < somefile.js > somefile.annotate.js\n```\n\n## Conventions\n`ngmin` does not currently attempt to be fully generalized, and might not work if you're too clever. If you follow these conventions, which are the same as what the AngularJS Yeoman generator defaults, you should be fine.\n\n### Module Declaration\n\n```javascript\n// like this\nangular.module('myModuleName', ['dependOnThisModule']);\n```\n\n### Controller Declaration\n\n```javascript\n// like this\nangular.module('myModuleName').controller('MyCtrl', function ($scope) {\n  // ...\n});\n```\n\n### Service Declaration\nThis should work for all injectable APIs.\n\n```javascript\n// like this\nangular.module('myModuleName').service('myService', function ($scope) {\n  // ...\n});\n```\n\n### Chaining\nYou can methods like this, and `ngmin` should still work fine:\n\n```javascript\n// like this\nangular.module('myModuleName').\n  service('myFirstService', function ($scope) {\n    // ...\n  }).\n  service('mySecondService', function ($scope) {\n    // ...\n  });\n```\n\nThis works with all injectable APIs.\n\n### References\nThis is not the preferred way of dealing with modules, and thus support for it isn't completely comprehensive. Something like this will work:\n```javascript\nvar myMod = angular.module('myMod', []);\nmyMod.service('myService', function ($scope) {\n  // ...\n});\n```\n\nBut something like this will probably fail spectacularly:\n```javascript\nvar myMod = angular.module('myMod', []);\nvar mod1, mod2, mod3;\nmod1 = myMod;\nmod3 = (function () {\n  return mod2 = mod1;\n}());\nmod3.service('myService', function ($scope) {\n  // ...\n});\n```\n\nPlease don't write code like the second example. :)\n\n## Conceptual Overview\nAngularJS's DI system inspects function parameters to determine what to inject:\n```javascript\n// angular knows to inject \"myService\" based on the parameter in \"myFactory\"\nsomeModule.factory('myFactory', function (myService) {\n  // ...\n});\n```\nAngularJS does this for `Module#controller`, `Module#service`, `Module#factory`, etc. Check out the [developer guide on DI](http://docs.angularjs.org/guide/di) for more info.\n\nJavaScript minifiers rename function parameters. The code above, when minified, might look like this:\n```javascript\n// the \"myService\" parameter has been renamed to \"a\" to save precious bytes\nsomeModule.factory('myFactory', function (a) {\n  // ...\n});\n```\n\nTo overcome this, AngularJS has a \"minifier-safe inline\" notation (see [Inline Annotation](http://docs.angularjs.org/guide/di) in the docs) that annotates `angular.controller`, `angular.service`, `angular.factory` with an array of dependencies' names as strings:\n```javascript\n// angular knows to inject \"myService\" based on the parameter in \"myFactory\"\nsomeModule.factory('myFactory', ['myService', function (myService) {\n  // ...\n}]);\n```\n\nSo with this notation, when minified, still includes the correct dependency names even if the function arguments are re-written:\n```javascript\nsomeModule.factory('myFactory', ['myService', function (a) {\n  // minified variable \"a\" will represent \"myService\"\n  // ...\n}]);\n```\n\nWriting the \"minifier-safe\" version by hand is kind of annoying because you have to keep both the array of dependency names and function parameters in sync.\n\n## License\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/btford/ngmin/issues"
  },
  "homepage": "https://github.com/btford/ngmin",
  "_id": "ngmin@0.4.1",
  "dist": {
    "shasum": "8e022dde28d190cb4c5e727d47f4133d0b4c338f"
  },
  "_from": "ngmin@0.4.1",
  "_resolved": "https://registry.npmjs.org/ngmin/-/ngmin-0.4.1.tgz"
}
