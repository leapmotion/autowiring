<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: Autofilters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.7.6</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li class="current"><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_devguide__auto_filters.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Autofilters </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>AutoFilters make it easier to construct and extend complex processing flows. While it may be straightforward enough to create a filter graph for a well-defined network in the conventional way, consider the problem of adding to or changing the network. If you add a new step to the process or change the design such that data available early in the process must also be available later in the process, you could have significant replumbing to do. With autowiring's' inversion of control, filters in the network declare what kinds of data they take in and what kinds of data they put out. Autowiring handles the connections.</p>
<p>The vessel that carries data from one filter to the next is the <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>. An <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> begins life as an “empty” object. The packet is subsequently "decorated" with data. AutoFilters in the network consume the packet by declaring a special function that specifies the input data types the filter requires to do its job. A filter can decorate the packet with additional data, which lets other filters which require that data to process the packet.</p>
<p>The packet lifespan ends when all current AutoFilter functions have returned and have not added decorations that trigger other filters in the network. (<a class="el" href="class_deferred.html" title="Marker return type for deferred calls ">Deferred</a> auto filters are an exception to this — the packet will persist at least until the deferred filter is run.) Technically, the <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> is held as a std::shared_ptr, once all references to the pointer are released, the packet is destroyed.</p>
<p>The context forms the boundaries of a filter network. There are two ways around this. You can snoop and you can use a lambda function.</p>
<h1>Rules of a packet filter network:</h1>
<ul>
<li>Each filter gets called at most once for a packet.</li>
<li>A type can only define one AutoFilter method.</li>
<li>Decorations cannot be removed from a packet.</li>
<li>A packet can only be decorated with a specific type once.</li>
</ul>
<h1>Defining an AutoFilter Function:</h1>
<p>You can create a filter with any object by implementing a function named AutoFilter. The arguments of the function declares both the input types of the filter and the output types. Const references and arguments passed by value are inputs. Non-const references are output types. The following example creates a class implementing an AutoFilter that takes two inputs and has one output:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>BasicFilter {</div>
<div class="line">    <span class="keywordtype">void</span> AutoFilter(T inputByValue, <span class="keyword">const</span> Q&amp; inputByRef, W&amp; output){</div>
<div class="line">        output.property = inputByValue.attribute + inputByRef.member;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The function is called when instances of types T and Q are added to the packet. On exit from the function, the type W is added to the packet.</p>
<h2>Arguments</h2>
<p>Autowiring uses the form of the argument to determine whether it is an input or an output. Pass-by-value and const arguments are inputs. Pass-by-reference arguments are outputs.</p>
<h3>Input arguments</h3>
<ul>
<li><code>T</code> — type T is an input passed by value <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(T value){}</div>
</div><!-- fragment --></li>
<li><code>const T&amp;</code> — T is an input, passed by reference. <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(<span class="keyword">const</span> T&amp; reference){}</div>
</div><!-- fragment --></li>
<li><code>shared_ptr&lt;const T&gt; p</code> — p is a shared_ptr to input of type T. You can keep p as long as necessary; the shared object won’t be released until after you release p. <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(std::shared_ptr&lt;const T&gt; pointer){}</div>
</div><!-- fragment --></li>
<li><code>T*[]</code> — A null-terminated array of pointers to type T. A pointer to an instance of T is added for each filter that adds an instance of T to the packet. The filter taking this input is called when all filters outputting T have run (or no more can run). <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(T* arg[]){}</div>
</div><!-- fragment --></li>
<li><code>T&amp;&amp;</code> — A synchronizing decoration. The previous value is removed from the packet. The filter function can assign a new value. Use for inplace modification of a data item in the packet. <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(T&amp;&amp; temp){}</div>
</div><!-- fragment --></li>
</ul>
<h3>Output argumets</h3>
<ul>
<li><code>T&amp;</code> — T is a filter output. An instance of T is constructed with its default constructor and passed to the function where it can be modified. The type is automatically added as a packet decoration after the function exits. <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(T&amp; reference){}</div>
</div><!-- fragment --></li>
<li><code>shared_ptr&lt;T&gt; &amp;p</code> — p is a pointer to an output type that this AutoFilter function must construct. This form is useful when type T doesn’t have a default constructor, or there are other reasons not to call it. <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(std::shared_ptr&lt;T&gt; pointer){}</div>
</div><!-- fragment --></li>
</ul>
<h3>Special arguments</h3>
<ul>
<li><code><a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> &amp;packet</code> — provides a reference to the packet itself. This argument is not treated as an input or output; other arguments determine when the filter function is called. <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(<a class="code" href="class_auto_packet.html">AutoPacket</a> &amp;packet){}</div>
</div><!-- fragment --></li>
</ul>
<p>.. * <code>AutoPrev &amp;previous</code> &ndash;</p>
<p>Note that a filter function with no input arguments is called when a new, empty packet is called.</p>
<h2>Return types:</h2>
<ul>
<li><code>void</code> &ndash; AutoFilter functions do not return a value. Instead, data is passed out of the function using output arguments. <div class="fragment"><div class="line"><span class="keywordtype">void</span> AutoFilter(T input, W&amp; output){}</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="class_deferred.html" title="Marker return type for deferred calls ">Deferred</a></code> — Using the special <a class="el" href="class_deferred.html" title="Marker return type for deferred calls ">Deferred</a> return type creates a deferred AutoFilter. The class declaring this function must inherit the <a class="el" href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ...">CoreThread</a> class. The function is added to the CoreThread’s dispatch queue when its input arguments are satisfied instead of being invoked immediately. Return <code><a class="el" href="class_deferred.html" title="Marker return type for deferred calls ">Deferred(this)</a></code> from the function. <div class="fragment"><div class="line"><span class="keyword">class </span>DeferredFilter : <span class="keyword">public</span> <a class="code" href="class_core_thread.html">CoreThread</a>{</div>
<div class="line">    <a class="code" href="class_deferred.html">Deferred</a> AutoFilter(T input, W&amp; output){</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="class_deferred.html">Deferred</a>(<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<h1>Creating a filter graph</h1>
<p>To create a filter graph network:</p>
<ol type="1">
<li>Implement the desired filter classes, each with an AutoFilter function.</li>
<li>Autowire these types into a context.</li>
<li>Initiate the context.</li>
<li>Create a packet using the context's <a class="el" href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool ">AutoPacketFactory</a>.</li>
<li>Decorate the packet with a data type (unless one of your filter functions takes an empty packet as input).</li>
</ol>
<p>The following example shows a hypothetical filter graph that takes a camera image, runs a blur filter, and then line and circle feature finding filters:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Image{};</div>
<div class="line"><span class="keyword">struct </span>RawImage: <span class="keyword">public</span> Image{};</div>
<div class="line"><span class="keyword">struct </span>BlurredImage: <span class="keyword">public</span> Image{};</div>
<div class="line"><span class="keyword">struct </span>CircleList{};</div>
<div class="line"><span class="keyword">struct </span>LineList{};</div>
<div class="line"><span class="keyword">struct </span>FeatureList{};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>Camera{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <a class="code" href="class_auto_required.html">AutoRequired&lt;AutoPacketFactory&gt;</a> packetGenerator;</div>
<div class="line">        <span class="keywordtype">void</span> produceImage(<span class="keywordtype">int</span> <span class="keywordtype">id</span>){</div>
<div class="line">            RawImage raw;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Produced raw image # &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keyword">auto</span> packet = packetGenerator-&gt;NewPacket();</div>
<div class="line">            packet-&gt;Decorate(raw);</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>BlurFilter{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> AutoFilter(<span class="keyword">const</span> RawImage img, BlurredImage &amp;blurred){</div>
<div class="line">            blurred = blur(img);</div>
<div class="line">        }</div>
<div class="line">        BlurredImage blur(<span class="keyword">const</span> RawImage raw){</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Blurred image.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> BlurredImage();</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>CircleFinder {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> AutoFilter(<span class="keyword">const</span> BlurredImage img, CircleList &amp;circles){</div>
<div class="line">            circles = findCircles(img);</div>
<div class="line">        }</div>
<div class="line">        CircleList findCircles(<span class="keyword">const</span> BlurredImage blurred){</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Found circles.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> CircleList();</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>LineFinder {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <a class="code" href="class_auto_required.html">AutoRequired&lt;AutoPacketFactory&gt;</a> packetGenerator;</div>
<div class="line">        <span class="keywordtype">void</span> AutoFilter(<span class="keyword">const</span> BlurredImage img, LineList &amp;lines){</div>
<div class="line">            lines = findLines(img);</div>
<div class="line">        }</div>
<div class="line">        LineList findLines(<span class="keyword">const</span> BlurredImage blurred){</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Found lines.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> LineList();</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>GraphOut {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> AutoFilter(<span class="keyword">const</span> CircleList circles, <span class="keyword">const</span> LineList lines, <a class="code" href="class_auto_packet.html">AutoPacket</a> &amp;packet){</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Received final packet with lines and circles. &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContext</a> ctxt;</div>
<div class="line">ctxt-&gt;SetCurrent();</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;Camera&gt;</a> camera;</div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;BlurFilter&gt;</a> blurFilter;</div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;CircleFinder&gt;</a> circleFilter;</div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;LineFinder&gt;</a> lineFilter;</div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;GraphOut&gt;</a> graphOutput;</div>
<div class="line"></div>
<div class="line">ctxt-&gt;Initiate();</div>
<div class="line"></div>
<div class="line">camera-&gt;produceImage(1);</div>
</div><!-- fragment --><p>All filters in the same context are part of the same network. You can design things so that parts of the graph never intersect, but the pontential for type collisions and hence unintended interaction exists.</p>
<h1>Decorating packets</h1>
<p>AutoFilter functions implicitly decorate packets by implementing an output argument. You can also explicitly decorate a packet with the Decorate() and DecorateImmediate() functions.</p>
<p>The Decorate() function works the same as an AutoFilter output. DecorateImmediate() is for time-critical data, such as items that have a very short lifespan. When you call DecorateImmediate(T), every AutoFilter function that takes the type T and whose other inputs are satisfied is invoked before DecorateImmediate() returns. After that, type T is marked as unsatisfiable and no other functions that take type T are invoked for the current packet. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 6 2016 16:27:05 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
