<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: DispatchQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.7.5</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_dispatch_queue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_dispatch_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DispatchQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is an asynchronous queue of zero-argument functions  
 <a href="class_dispatch_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_dispatch_queue_8h_source.html">DispatchQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DispatchQueue:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_dispatch_queue.png" usemap="#DispatchQueue_map" alt=""/>
  <map id="DispatchQueue_map" name="DispatchQueue_map">
<area href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ..." alt="CoreThread" shape="rect" coords="0,56,99,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa62c1140f05c7513bc80668aa724684c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aa62c1140f05c7513bc80668aa724684c">~DispatchQueue</a> (void)</td></tr>
<tr class="memdesc:aa62c1140f05c7513bc80668aa724684c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs down the dispatch queue without calling anything  <a href="#aa62c1140f05c7513bc80668aa724684c">More...</a><br /></td></tr>
<tr class="separator:aa62c1140f05c7513bc80668aa724684c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3193aa5422bf9e1aa80e1c1e9a913016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a3193aa5422bf9e1aa80e1c1e9a913016">Abort</a> (void)</td></tr>
<tr class="memdesc:a3193aa5422bf9e1aa80e1c1e9a913016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the current dispatch queue to be dumped if it's non-empty  <a href="#a3193aa5422bf9e1aa80e1c1e9a913016">More...</a><br /></td></tr>
<tr class="separator:a3193aa5422bf9e1aa80e1c1e9a913016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecb6036d42a7b56e960713f4f9630a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a1ecb6036d42a7b56e960713f4f9630a0">AddExisting</a> (std::unique_ptr&lt; DispatchThunkBase &gt; &amp;&amp;pBase)</td></tr>
<tr class="memdesc:a1ecb6036d42a7b56e960713f4f9630a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit overload for already-constructed dispatch thunk types  <a href="#a1ecb6036d42a7b56e960713f4f9630a0">More...</a><br /></td></tr>
<tr class="separator:a1ecb6036d42a7b56e960713f4f9630a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee3c640b1c46dc87157d7e1186db9bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a9ee3c640b1c46dc87157d7e1186db9bc">AreAnyDispatchersReady</a> (void) const </td></tr>
<tr class="separator:a9ee3c640b1c46dc87157d7e1186db9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dd84e1f8c210b971b9b08f89b8af10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a36dd84e1f8c210b971b9b08f89b8af10">Barrier</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a36dd84e1f8c210b971b9b08f89b8af10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all dispatchers on the <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> at the time of the call have been dispatched  <a href="#a36dd84e1f8c210b971b9b08f89b8af10">More...</a><br /></td></tr>
<tr class="separator:a36dd84e1f8c210b971b9b08f89b8af10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202af0ec4502042b5fb32c0dfc4cdfa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a202af0ec4502042b5fb32c0dfc4cdfa8">Barrier</a> (void)</td></tr>
<tr class="memdesc:a202af0ec4502042b5fb32c0dfc4cdfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the timed version of Barrier, but does not time out  <a href="#a202af0ec4502042b5fb32c0dfc4cdfa8">More...</a><br /></td></tr>
<tr class="separator:a202af0ec4502042b5fb32c0dfc4cdfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94131c04ad4d1513cc411870fc6b002"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#af94131c04ad4d1513cc411870fc6b002">DispatchAllEvents</a> (void)</td></tr>
<tr class="memdesc:af94131c04ad4d1513cc411870fc6b002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to DispatchEvent, but will attempt to dispatch all events currently queued  <a href="#af94131c04ad4d1513cc411870fc6b002">More...</a><br /></td></tr>
<tr class="separator:af94131c04ad4d1513cc411870fc6b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf0ed4b428ecbee03fb64a0e705ce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ae4cf0ed4b428ecbee03fb64a0e705ce7">DispatchEvent</a> (void)</td></tr>
<tr class="memdesc:ae4cf0ed4b428ecbee03fb64a0e705ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to WaitForEvent, but does not block  <a href="#ae4cf0ed4b428ecbee03fb64a0e705ce7">More...</a><br /></td></tr>
<tr class="separator:ae4cf0ed4b428ecbee03fb64a0e705ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead80f32b70b6c6ee5acffb2b083724a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aead80f32b70b6c6ee5acffb2b083724a">GetDispatchQueueLength</a> (void) const </td></tr>
<tr class="separator:aead80f32b70b6c6ee5acffb2b083724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993c2a6b31496f06d47079a56086a507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a993c2a6b31496f06d47079a56086a507">operator+=</a> (<a class="el" href="class_dispatch_queue.html">DispatchQueue</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a993c2a6b31496f06d47079a56086a507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the contents of the dispatch queue on the right-hand side for handling by this queue  <a href="#a993c2a6b31496f06d47079a56086a507">More...</a><br /></td></tr>
<tr class="separator:a993c2a6b31496f06d47079a56086a507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef60c207a481b40c252b120ff366fe5"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a4ef60c207a481b40c252b120ff366fe5"><td class="memTemplItemLeft" align="right" valign="top">DispatchThunkDelayedExpressionRel&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a4ef60c207a481b40c252b120ff366fe5">operator+=</a> (std::chrono::duration&lt; Rep, Period &gt; rhs)</td></tr>
<tr class="memdesc:a4ef60c207a481b40c252b120ff366fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for the introduction of a delayed dispatch thunk  <a href="#a4ef60c207a481b40c252b120ff366fe5">More...</a><br /></td></tr>
<tr class="separator:a4ef60c207a481b40c252b120ff366fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef21ddeababdb9cc0fffa7f9f5d557f"><td class="memItemLeft" align="right" valign="top">DispatchThunkDelayedExpressionAbs&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a5ef21ddeababdb9cc0fffa7f9f5d557f">operator+=</a> (std::chrono::steady_clock::time_point rhs)</td></tr>
<tr class="memdesc:a5ef21ddeababdb9cc0fffa7f9f5d557f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for absolute-time based delayed dispatch thunk  <a href="#a5ef21ddeababdb9cc0fffa7f9f5d557f">More...</a><br /></td></tr>
<tr class="separator:a5ef21ddeababdb9cc0fffa7f9f5d557f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43ba9a08cec6888a103f94f6e2dabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ada43ba9a08cec6888a103f94f6e2dabb">operator+=</a> (DispatchThunkDelayed &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ada43ba9a08cec6888a103f94f6e2dabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly pends a delayed dispatch thunk  <a href="#ada43ba9a08cec6888a103f94f6e2dabb">More...</a><br /></td></tr>
<tr class="separator:ada43ba9a08cec6888a103f94f6e2dabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="memTemplParams" colspan="2">template&lt;class _Fx &gt; </td></tr>
<tr class="memitem:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a8dfd34970fbfca53f0d3b10cbb9c433c">operator+=</a> (_Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic overload which will pend an arbitrary dispatch type  <a href="#a8dfd34970fbfca53f0d3b10cbb9c433c">More...</a><br /></td></tr>
<tr class="separator:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e780c30d55fffc706892e1ebb160a"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a457e780c30d55fffc706892e1ebb160a">SuggestSoonestWakeupTimeUnsafe</a> (std::chrono::steady_clock::time_point latestTime) const </td></tr>
<tr class="memdesc:a457e780c30d55fffc706892e1ebb160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommends a point in time to wake up to check for events  <a href="#a457e780c30d55fffc706892e1ebb160a">More...</a><br /></td></tr>
<tr class="separator:a457e780c30d55fffc706892e1ebb160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304588a65ecc0712c3aafe0461c73f1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a304588a65ecc0712c3aafe0461c73f1b">WaitForEvent</a> (void)</td></tr>
<tr class="memdesc:a304588a65ecc0712c3aafe0461c73f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a lambda function is ready to run in this thread's dispatch queue, dispatches the function, and then returns.  <a href="#a304588a65ecc0712c3aafe0461c73f1b">More...</a><br /></td></tr>
<tr class="separator:a304588a65ecc0712c3aafe0461c73f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa284e235b0971d36bd858dc320c1a853"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aa284e235b0971d36bd858dc320c1a853">WaitForEvent</a> (std::chrono::milliseconds milliseconds)</td></tr>
<tr class="memdesc:aa284e235b0971d36bd858dc320c1a853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a lambda function in the dispatch queue is ready to run or the specified time period elapses, whichever comes first.  <a href="#aa284e235b0971d36bd858dc320c1a853">More...</a><br /></td></tr>
<tr class="separator:aa284e235b0971d36bd858dc320c1a853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e2d4588e439c8a0425ce0c50dc0f25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ad9e2d4588e439c8a0425ce0c50dc0f25">WaitForEvent</a> (std::chrono::steady_clock::time_point wakeTime)</td></tr>
<tr class="memdesc:ad9e2d4588e439c8a0425ce0c50dc0f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a lambda function in the dispatch queue is ready to run or the specified time is reached, whichever comes first.  <a href="#ad9e2d4588e439c8a0425ce0c50dc0f25">More...</a><br /></td></tr>
<tr class="separator:ad9e2d4588e439c8a0425ce0c50dc0f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3293e212f176ae7a11cbb4690cce71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#afd3293e212f176ae7a11cbb4690cce71">WakeAllWaitingThreads</a> (void)</td></tr>
<tr class="memdesc:afd3293e212f176ae7a11cbb4690cce71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all calls to WaitForEvent to return control to their callers  <a href="#afd3293e212f176ae7a11cbb4690cce71">More...</a><br /></td></tr>
<tr class="separator:afd3293e212f176ae7a11cbb4690cce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7c909a2f706599e2aeaea163afc43d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a7c909a2f706599e2aeaea163afc43d2a">DispatchEventUnsafe</a> (std::unique_lock&lt; std::mutex &gt; &amp;lk)</td></tr>
<tr class="memdesc:a7c909a2f706599e2aeaea163afc43d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to DispatchEvent, except assumes that the dispatch lock is currently held  <a href="#a7c909a2f706599e2aeaea163afc43d2a">More...</a><br /></td></tr>
<tr class="separator:a7c909a2f706599e2aeaea163afc43d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7d922485f14bdbb72559df2e009b40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6c7d922485f14bdbb72559df2e009b40">OnPended</a> (std::unique_lock&lt; std::mutex &gt; &amp;&amp;lk)</td></tr>
<tr class="memdesc:a6c7d922485f14bdbb72559df2e009b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility virtual, called whenever a new event is deferred  <a href="#a6c7d922485f14bdbb72559df2e009b40">More...</a><br /></td></tr>
<tr class="separator:a6c7d922485f14bdbb72559df2e009b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6603bb739523587631367935af2aea36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6603bb739523587631367935af2aea36">PendExisting</a> (std::unique_lock&lt; std::mutex &gt; &amp;&amp;lk, DispatchThunkBase *thunk)</td></tr>
<tr class="memdesc:a6603bb739523587631367935af2aea36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches an element to the end of the dispatch queue without any checks.  <a href="#a6603bb739523587631367935af2aea36">More...</a><br /></td></tr>
<tr class="separator:a6603bb739523587631367935af2aea36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad392c934d343fb56f8c233d2fbd6243b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ad392c934d343fb56f8c233d2fbd6243b">PromoteReadyDispatchersUnsafe</a> (void)</td></tr>
<tr class="memdesc:ad392c934d343fb56f8c233d2fbd6243b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all ready events from the delayed queue into the dispatch queue  <a href="#ad392c934d343fb56f8c233d2fbd6243b">More...</a><br /></td></tr>
<tr class="separator:ad392c934d343fb56f8c233d2fbd6243b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e455ffdaece9c129717211f13752fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6e455ffdaece9c129717211f13752fa3">SetDispatcherCap</a> (size_t dispatchCap)</td></tr>
<tr class="memdesc:a6e455ffdaece9c129717211f13752fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the upper bound on the number of allowed pending dispatchers  <a href="#a6e455ffdaece9c129717211f13752fa3">More...</a><br /></td></tr>
<tr class="separator:a6e455ffdaece9c129717211f13752fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is an asynchronous queue of zero-argument functions </p>
<p>A <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> is a type of event receiver which allows for the reception of deferred events. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa62c1140f05c7513bc80668aa724684c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DispatchQueue::~DispatchQueue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs down the dispatch queue without calling anything </p>
<p>Nothing in the destructor is synchronized. This is done under the assumption that multi- access during teardown is impossible. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3193aa5422bf9e1aa80e1c1e9a913016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::Abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the current dispatch queue to be dumped if it's non-empty </p>
<p>This method should only be called if a non-graceful termination is desired. In this case, the dispatch queue will be immediately cleared and any subsequent calls to WaitForEvent or DispatchEvent will throw a dispatch_aborted_exception.</p>
<p>Callers who are willing to allow the dispatch queue to be fully processed should call Rundown instead.</p>
<p>This method is idempotent </p>

</div>
</div>
<a class="anchor" id="a1ecb6036d42a7b56e960713f4f9630a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::AddExisting </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; DispatchThunkBase &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>pBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit overload for already-constructed dispatch thunk types </p>

</div>
</div>
<a class="anchor" id="a9ee3c640b1c46dc87157d7e1186db9bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::AreAnyDispatchersReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if there are curerntly any dispatchers ready for execution&ndash;IE, DispatchEvent would return true </dd></dl>

</div>
</div>
<a class="anchor" id="a36dd84e1f8c210b971b9b08f89b8af10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::Barrier </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until all dispatchers on the <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> at the time of the call have been dispatched </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<p>This method does not cause any dispatchers to run. If the underlying dispatch queue does not have an event loop operating on it, this method will deadlock. It is an error for the party responsible for driving the dispatch queue via WaitForEvent or DispatchAllEvents unless that party first delegates the responsibility elsewhere.</p>
<p>If <a class="el" href="class_dispatch_queue.html#a3193aa5422bf9e1aa80e1c1e9a913016" title="Causes the current dispatch queue to be dumped if it&#39;s non-empty ">DispatchQueue::Abort()</a> is called before the dispatcher has been completed, this method will throw an exception. If a dispatcher on the underlying <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> throws an exception, this method will also throw an exception.</p>
<p>If zero is passed as the timeout value, this method will return true if and only if the queue was empty at the time of the call, ignoring any delayed dispatchers. </p>

</div>
</div>
<a class="anchor" id="a202af0ec4502042b5fb32c0dfc4cdfa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::Barrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the timed version of Barrier, but does not time out </p>

</div>
</div>
<a class="anchor" id="af94131c04ad4d1513cc411870fc6b002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DispatchQueue::DispatchAllEvents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to DispatchEvent, but will attempt to dispatch all events currently queued </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of events dispatched</dd></dl>

</div>
</div>
<a class="anchor" id="ae4cf0ed4b428ecbee03fb64a0e705ce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::DispatchEvent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to WaitForEvent, but does not block </p>
<dl class="section return"><dt>Returns</dt><dd>True if an event was dispatched, false if the queue was empty when checked</dd></dl>
<p>If the dispatch queue is empty, this method will check the delayed dispatch queue. </p>

</div>
</div>
<a class="anchor" id="a7c909a2f706599e2aeaea163afc43d2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::DispatchEventUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to DispatchEvent, except assumes that the dispatch lock is currently held </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lk</td><td>A lock on m_dispatchLock</td></tr>
  </table>
  </dd>
</dl>
<p>This method assumes that the dispatch lock is held and that m_aborted is false. It is an error to call this method without those preconditions met. </p>

</div>
</div>
<a class="anchor" id="aead80f32b70b6c6ee5acffb2b083724a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t DispatchQueue::GetDispatchQueueLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total number of all ready and delayed events </dd></dl>
<p>This method will also count dispatchers that are presently underway or presently being deleted. Thus, calling this method from within a dispatcher, or from that dispatcher's destructor, should always return a size of at least 1. </p>

</div>
</div>
<a class="anchor" id="a6c7d922485f14bdbb72559df2e009b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DispatchQueue::OnPended </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility virtual, called whenever a new event is deferred </p>
<p>The recipient of this call will be running in an arbitrary thread context while holding the dispatch lock. The queue is guaranteed to contain at least one element, and may potentially contain more. The caller MUST NOT attempt to pend any more events during this call, or a deadlock could occur. </p>

<p>Referenced by <a class="el" href="class_dispatch_queue.html#a8dfd34970fbfca53f0d3b10cbb9c433c">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="a993c2a6b31496f06d47079a56086a507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_dispatch_queue.html">DispatchQueue</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the contents of the dispatch queue on the right-hand side for handling by this queue </p>

</div>
</div>
<a class="anchor" id="a4ef60c207a481b40c252b120ff366fe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DispatchThunkDelayedExpressionRel DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for the introduction of a delayed dispatch thunk </p>
<p>If the passed duration is equal to zero, the returned expression template will pend a lambda to the dispatch queue as though that lambda were added with operator+= without any delay. </p>

</div>
</div>
<a class="anchor" id="a5ef21ddeababdb9cc0fffa7f9f5d557f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DispatchThunkDelayedExpressionAbs DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for absolute-time based delayed dispatch thunk </p>

</div>
</div>
<a class="anchor" id="ada43ba9a08cec6888a103f94f6e2dabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">DispatchThunkDelayed &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly pends a delayed dispatch thunk </p>
<p>This overload will always succeed and does not consult the dispatch cap </p>

</div>
</div>
<a class="anchor" id="a8dfd34970fbfca53f0d3b10cbb9c433c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">_Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic overload which will pend an arbitrary dispatch type </p>

</div>
</div>
<a class="anchor" id="a6603bb739523587631367935af2aea36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::PendExisting </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DispatchThunkBase *&#160;</td>
          <td class="paramname"><em>thunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches an element to the end of the dispatch queue without any checks. </p>

<p>Referenced by <a class="el" href="class_dispatch_queue.html#a1ecb6036d42a7b56e960713f4f9630a0">AddExisting()</a>.</p>

</div>
</div>
<a class="anchor" id="ad392c934d343fb56f8c233d2fbd6243b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::PromoteReadyDispatchersUnsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves all ready events from the delayed queue into the dispatch queue </p>
<dl class="section return"><dt>Returns</dt><dd>True if at least one dispatcher was promoted</dd></dl>

</div>
</div>
<a class="anchor" id="a6e455ffdaece9c129717211f13752fa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::SetDispatcherCap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dispatchCap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the upper bound on the number of allowed pending dispatchers </p>

</div>
</div>
<a class="anchor" id="a457e780c30d55fffc706892e1ebb160a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::steady_clock::time_point DispatchQueue::SuggestSoonestWakeupTimeUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>latestTime</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recommends a point in time to wake up to check for events </p>
<dl class="section return"><dt>Returns</dt><dd>lastestTime, or if there is a dispatch in the delayed queue which will be ready sooner than latestTime, the time_point when that dispatch will be ready to run. </dd></dl>
<p>This method is used by clients that are performing manual dispatch operations and wish to know the shortest time they should sleep in order to be guaranteed that, upon waking, a dispatch will be ready to run.</p>
<p>Users should be aware that another dispatch may arrive which is ready to run sooner than the returned suggestion. Notification of this case will be provided to derived classes via the OnPended override. </p>

</div>
</div>
<a class="anchor" id="a304588a65ecc0712c3aafe0461c73f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::WaitForEvent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a lambda function is ready to run in this thread's dispatch queue, dispatches the function, and then returns. </p>

</div>
</div>
<a class="anchor" id="aa284e235b0971d36bd858dc320c1a853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::WaitForEvent </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a lambda function in the dispatch queue is ready to run or the specified time period elapses, whichever comes first. </p>
<dl class="section return"><dt>Returns</dt><dd>False if the timeout period elapsed before an event could be dispatched, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad9e2d4588e439c8a0425ce0c50dc0f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::WaitForEvent </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>wakeTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a lambda function in the dispatch queue is ready to run or the specified time is reached, whichever comes first. </p>
<dl class="section return"><dt>Returns</dt><dd>False if the timeout period elapsed before an event could be dispatched, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="afd3293e212f176ae7a11cbb4690cce71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::WakeAllWaitingThreads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes all calls to WaitForEvent to return control to their callers </p>
<p>This method will cause any threads blocked in WaitForEvent to wake up and make progress. This can be useful when threads are being used to dispatch work items and it's necessary to wake them in order to handle out-of-queue processing&ndash;IE, pool maintenance </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_dispatch_queue_8h_source.html">DispatchQueue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_dispatch_queue.html">DispatchQueue</a></li>
    <li class="footer">Generated on Thu Oct 15 2015 13:21:46 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
