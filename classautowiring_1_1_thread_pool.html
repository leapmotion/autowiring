<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: autowiring::ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.7.7</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classautowiring_1_1_thread_pool.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classautowiring_1_1_thread_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">autowiring::ThreadPool Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic interface for a thread pool  
 <a href="classautowiring_1_1_thread_pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autowiring::ThreadPool:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classautowiring_1_1_thread_pool.png" usemap="#autowiring::ThreadPool_map" alt=""/>
  <map id="autowiring::ThreadPool_map" name="autowiring::ThreadPool_map">
<area href="classautowiring_1_1_system_thread_pool.html" title="A thread pool that makes use of the underlying system&#39;s APIs " alt="autowiring::SystemThreadPool" shape="rect" coords="0,56,181,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4e0e0f0ed07a8f7eecb902e477e7400"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautowiring_1_1_thread_pool.html#ad4e0e0f0ed07a8f7eecb902e477e7400">Consume</a> (const std::shared_ptr&lt; <a class="el" href="class_dispatch_queue.html">DispatchQueue</a> &gt; &amp;dq)</td></tr>
<tr class="memdesc:ad4e0e0f0ed07a8f7eecb902e477e7400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the thread pool to call all lambdas specified on the passed <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a>  <a href="#ad4e0e0f0ed07a8f7eecb902e477e7400">More...</a><br /></td></tr>
<tr class="separator:ad4e0e0f0ed07a8f7eecb902e477e7400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdad28cbbe451fc38b99e026648ed83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fdad28cbbe451fc38b99e026648ed83"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautowiring_1_1_thread_pool.html#a4fdad28cbbe451fc38b99e026648ed83">IsStarted</a> (void) const </td></tr>
<tr class="memdesc:a4fdad28cbbe451fc38b99e026648ed83"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if the thread pool is running</dd></dl>
<br /></td></tr>
<tr class="separator:a4fdad28cbbe451fc38b99e026648ed83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0dc654fe77523edcc62983603b201b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautowiring_1_1_thread_pool.html#a1e0dc654fe77523edcc62983603b201b">Start</a> (void)</td></tr>
<tr class="memdesc:a1e0dc654fe77523edcc62983603b201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins processing on this thread pool  <a href="#a1e0dc654fe77523edcc62983603b201b">More...</a><br /></td></tr>
<tr class="separator:a1e0dc654fe77523edcc62983603b201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1c5c0ed7c110991635291062febcb2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautowiring_1_1_thread_pool.html#abd1c5c0ed7c110991635291062febcb2">Submit</a> (std::unique_ptr&lt; DispatchThunkBase &gt; &amp;&amp;thunk)=0</td></tr>
<tr class="memdesc:abd1c5c0ed7c110991635291062febcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified thunk to be executed by the thread pool at some later time  <a href="#abd1c5c0ed7c110991635291062febcb2">More...</a><br /></td></tr>
<tr class="separator:abd1c5c0ed7c110991635291062febcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae17455e2f6abb95d1270357fd65eeaf8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautowiring_1_1_thread_pool.html#ae17455e2f6abb95d1270357fd65eeaf8">OnStartUnsafe</a> (void)</td></tr>
<tr class="memdesc:ae17455e2f6abb95d1270357fd65eeaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the thread pool is first started  <a href="#ae17455e2f6abb95d1270357fd65eeaf8">More...</a><br /></td></tr>
<tr class="separator:ae17455e2f6abb95d1270357fd65eeaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4c80aa10ca64fed35273b5fadd87d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautowiring_1_1_thread_pool.html#afa4c80aa10ca64fed35273b5fadd87d6">OnStop</a> (void)</td></tr>
<tr class="memdesc:afa4c80aa10ca64fed35273b5fadd87d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the thread pool is being cleaned up  <a href="#afa4c80aa10ca64fed35273b5fadd87d6">More...</a><br /></td></tr>
<tr class="separator:afa4c80aa10ca64fed35273b5fadd87d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic interface for a thread pool </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad4e0e0f0ed07a8f7eecb902e477e7400"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autowiring::ThreadPool::Consume </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_dispatch_queue.html">DispatchQueue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes the thread pool to call all lambdas specified on the passed <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> </p>
<p>The dispatchers on the <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> are executed sequentially with respect to each other. Each dispatcher is guaranteed to be destroyed before the next one is executed. Dispatchers may potentially be executed on different threads, depending on the exact details of the <a class="el" href="classautowiring_1_1_thread_pool.html" title="Generic interface for a thread pool ">ThreadPool</a>'s implementation. There is no guarantee of timeliness of execution provided by this implementation; the queue may be emptied before this function returns in some cases, or its state may not be changed at all. The <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> may be aborted while the pool has posession of it; this will cause the <a class="el" href="classautowiring_1_1_thread_pool.html" title="Generic interface for a thread pool ">ThreadPool</a> to abandon processing of the queue in the normal way.</p>
<p>Once the pool has emptied the queue, it stops processing dispatchers from it. The user must call Consume again in order to continue processing.</p>
<p>This method is guaranteed not to block. The default implementation captures the passed queue in a lambda and invokes Submit with this constructed lambda. </p>

</div>
</div>
<a class="anchor" id="ae17455e2f6abb95d1270357fd65eeaf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autowiring::ThreadPool::OnStartUnsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the thread pool is first started </p>
<p>This method is called at most once </p>

</div>
</div>
<a class="anchor" id="afa4c80aa10ca64fed35273b5fadd87d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autowiring::ThreadPool::OnStop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the thread pool is being cleaned up </p>
<p>Where possible, this method should return immediately. </p>

</div>
</div>
<a class="anchor" id="a1e0dc654fe77523edcc62983603b201b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;void&gt; autowiring::ThreadPool::Start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins processing on this thread pool </p>
<dl class="section return"><dt>Returns</dt><dd>A token that must be held in scope while the thread pool should be started</dd></dl>
<p>This method is idempotent. Unlike <a class="el" href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ...">CoreThread</a> instances, a thread pool may be restarted. The returned shared pointer must be held for as long as the thread pool should be kept running. If the returned token is destroyed, the thread pool will be stopped automatically. Termination of work items in the thread pool may occur at a later time on certain platforms; in some cases, a call to Start may result in the creation of a new thread pool before the previous thread pool is completely torn down. </p>

</div>
</div>
<a class="anchor" id="abd1c5c0ed7c110991635291062febcb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool autowiring::ThreadPool::Submit </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; DispatchThunkBase &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>thunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified thunk to be executed by the thread pool at some later time </p>
<dl class="section return"><dt>Returns</dt><dd>True if the job was successfully accepted, false otherwise</dd></dl>
<p>This method may be called even if the thread pool is not currently running. In that case, the job will be enqueued until the thread pool is started, at which time it will be submitted for execution. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceautowiring.html">autowiring</a></li><li class="navelem"><a class="el" href="classautowiring_1_1_thread_pool.html">ThreadPool</a></li>
    <li class="footer">Generated on Wed Jan 6 2016 16:25:20 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
